File Contents:

--- Buttons/DatePicker.js ---
// src/components/DatePickerComponent/DatePickerComponent.jsx

import React from 'react';
import DatePicker from 'react-datepicker';
import { FaCalendarAlt } from 'react-icons/fa';
import 'react-datepicker/dist/react-datepicker.css';
import {
  formatDateDutch,
  isToday,
} from '../../../Utils/dateUtils.js';
import './css/datePicker.css';

const DatePickerComponent = ({
  selectedDate,
  setSelectedDate,
  isDatePickerOpen,
  setIsDatePickerOpen,
}) => {
  const handleDateChange = (date) => {
    setSelectedDate(date);
    setIsDatePickerOpen(false);

    console.log("SELECTED" + date);
  };

  return (
    <div className="date-picker-component">
      {selectedDate && (
        <h2 className="selected-date">
          {isToday(selectedDate) ? 'Vandaag' : formatDateDutch(selectedDate)}
        </h2>
      )}

	   <button
        className="button-style-1 button-date"
		onClick={() => setIsDatePickerOpen(!isDatePickerOpen)}
      >

		
        <FaCalendarAlt className="button-style-1-icon" />
        {selectedDate
          ? isToday(selectedDate)
            ? 'Vandaag'
            : `${formatDateDutch(selectedDate)}`
          : 'Datum'}
      </button>

      <button
        onClick={() => setIsDatePickerOpen(!isDatePickerOpen)}
        className="button-style-1 date-button"
      >

		
        <FaCalendarAlt className="button-style-1-icon date-button-icon" />
        {selectedDate
          ? isToday(selectedDate)
            ? 'Vandaag'
            : `${formatDateDutch(selectedDate)}`
          : 'Datum'}
      </button>

      {isDatePickerOpen && (
        <div className="date-picker-popup">
          <DatePicker
            selected={selectedDate}
            onChange={handleDateChange}
            inline
            locale="nl"
            dateFormat="dd/MM/yyyy"
            placeholderText="Selecteer een datum"
            todayButton="Vandaag"
          />
        </div>
      )}
    </div>
  );
};

export default DatePickerComponent;


--- Buttons/ShiftSelector.js ---
// src/Buttons/ShiftSelector.js

import React, { useRef, useEffect } from 'react';
import { FaList } from 'react-icons/fa';
import './css/shiftSelector.css';

const ShiftSelector = ({
  shifts,
  selectedShift,
  setSelectedShift,
  isShiftOptionsOpen,
  setIsShiftOptionsOpen,
  onShiftSelect, // New prop
}) => {
  const shiftButtonRef = useRef(null);
  const shiftOptionsRef = useRef(null);

  // Handle Click Outside for Shift Options
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (
        shiftOptionsRef.current &&
        !shiftOptionsRef.current.contains(event.target) &&
        shiftButtonRef.current &&
        !shiftButtonRef.current.contains(event.target)
      ) {
        setIsShiftOptionsOpen(false);
      }
    };

    if (isShiftOptionsOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    } else {
      document.removeEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isShiftOptionsOpen, setIsShiftOptionsOpen]);

  const handleShiftSelection = (shift) => {
    setSelectedShift(shift);
    setIsShiftOptionsOpen(false);
    if (onShiftSelect) {
      onShiftSelect(shift); // Call the handler passed from DayCalendar
    }
  };

  const toggleShiftOptions = () => {
    setIsShiftOptionsOpen(!isShiftOptionsOpen);
  };

  return (
    <div className="shift-selector">
      <button
        onClick={toggleShiftOptions}
        className="button-style-1 shift-button"
        ref={shiftButtonRef}
      >
        <FaList className="button-style-1-icon shift-button-icon" />
        {selectedShift ? `${selectedShift}` : 'Shift'}
      </button>

      {isShiftOptionsOpen && (
        <div className="shift-options-container" ref={shiftOptionsRef}>
          {Object.keys(shifts).map((shift) => (
            <div
              key={shift}
              className="shift-option"
              onClick={() => handleShiftSelection(shift)}
            >
              {shift}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default ShiftSelector;


--- Hooks/fetchTimeblocks.js ---
// src/hooks/useTimeBlocks.js

import { useState, useEffect } from 'react';
import useApi from '../../../Hooks/useApi';
import { formatDateKey } from '../Utils/dateFormat';

const useTimeBlocks = (triggerNotification) => {
  const [blocks, setBlocks] = useState([]);
  const api = useApi();

  useEffect(() => {
    const fetchTimeBlocks = async () => {
      try {
        const response = await api.get(`${window.baseDomain}api/timeblocks/`, { noCache: true });
        const blocksData = response || [];
        setBlocks(blocksData);
      } catch (err) {
        console.error('[useTimeBlocks] Error fetching time blocks:', err);
      }
    };

    fetchTimeBlocks();
  }, [api]);

  const parseTime = (timeString) => {
    const [hours, minutes] = timeString.split(':').map(Number);
    return hours * 60 + minutes;
  };

  const isOverlapping = (newBlock, existingBlocks) => {
    const newStart = parseTime(newBlock.startTime);
    const newEnd = parseTime(newBlock.endTime);

    for (const block of existingBlocks) {
      if (block._id === newBlock._id) continue;
      const blockStart = parseTime(block.startTime);
      const blockEnd = parseTime(block.endTime);

      if (
        (newStart >= blockStart && newStart < blockEnd) ||
        (newEnd > blockStart && newEnd <= blockEnd) ||
        (newStart <= blockStart && newEnd >= blockEnd)
      ) {
        return true;
      }
    }
    return false;
  };

  const addTimeBlock = async (block) => {
    if (isOverlapping(block, blocks)) {
      triggerNotification('Tijdsblok overlapt met een bestaand tijdsblok', 'warning');
      return;
    }

    try {
      const response = await api.post(`${window.baseDomain}api/timeblocks/`, block);
      block._id = response.id;
      setBlocks((prevBlocks) => [...prevBlocks, block]);
      triggerNotification('Tijdsblok toegevoegd', 'success');
      return block;
    } catch (err) {
      console.error('[useTimeBlocks] Error adding time block:', err);
      throw err;
    }
  };

  const updateTimeBlock = async (block) => {
    if (isOverlapping(block, blocks)) {
      triggerNotification('Tijdsblok overlapt met een bestaand tijdsblok', 'warning');
      return;
    }

    try {
      const updateUrl = `${window.baseDomain}api/timeblocks/${block._id}/`;
      await api.put(updateUrl, block);
      setBlocks((prevBlocks) =>
        prevBlocks.map((b) => (b._id === block._id ? block : b))
      );
      triggerNotification('Tijdsblok bewerkt', 'success');
      return block;
    } catch (err) {
      console.error('[useTimeBlocks] Error updating time block:', err);
      throw err;
    }
  };

  const deleteTimeBlock = async (blockToDelete) => {
    try {
      const deleteUrl = `${window.baseDomain}api/timeblocks/${blockToDelete._id}/`;
      await api.delete(deleteUrl);
      setBlocks((prevBlocks) =>
        prevBlocks.filter((block) => block._id !== blockToDelete._id)
      );
      triggerNotification('Tijdsblok verwijderd', 'success');
    } catch (err) {
      console.error('[useTimeBlocks] Error deleting time block:', err);
    }
  };

  const handleTimeBlockMove = async (updatedBlock) => {
    if (isOverlapping(updatedBlock, blocks)) {
      triggerNotification('Tijdsblok overlapt met een bestaand tijdsblok', 'warning');
      return;
    }

    try {
      const updateUrl = `${window.baseDomain}api/timeblocks/${updatedBlock._id}/`;
      await api.put(updateUrl, updatedBlock);
      setBlocks((prevBlocks) =>
        prevBlocks.map((b) => (b._id === updatedBlock._id ? updatedBlock : b))
      );
      triggerNotification('Tijdsblok verplaatst', 'success');
    } catch (err) {
      console.error('[useTimeBlocks] Error moving time block:', err);
      triggerNotification('Fout bij het verplaatsen van het tijdsblok', 'error');
    }
  };

  return {
    blocks,
    addTimeBlock,
    updateTimeBlock,
    deleteTimeBlock,
    handleTimeBlockMove,
    formatDateKey,
  };
};

export default useTimeBlocks;


--- Hooks/useBlockPositions.js ---
// src/hooks/useBlockPositions.js

import { useState, useEffect } from 'react';

const useBlockPositions = (timeBlocks, hourHeight) => {
  const [blockPositions, setBlockPositions] = useState({});

  const parseTime = (timeString) => {
    const [hours, minutes] = timeString.split(':').map(Number);
    return hours * 60 + minutes;
  };

  useEffect(() => {
    const newPositions = {};
    timeBlocks.forEach((block) => {
      const startMinutes = parseTime(block.startTime);
      const yPosition = (startMinutes / 60) * hourHeight;
      newPositions[block._id] = { x: 0, y: yPosition };
    });
    setBlockPositions(newPositions);
  }, [timeBlocks, hourHeight]);

  return [blockPositions, setBlockPositions];
};

export default useBlockPositions;


--- Hooks/useDragHandlers.js ---
// src/components/Timeline/Hooks/useDragHandlers.js

import { useState, useRef } from 'react';
import { parseTime, formatMinutesToTime, roundToNearestInterval } from '../Utils/timeUtils';

const useDragHandlers = (
  hourHeight,
  snappingIntervalMinutes,
  onTimeBlockMove,
  getPixelOffset // Function to get the current pixelOffset
) => {
  const [dragging, setDragging] = useState(false);
  const dragTimeoutRef = useRef(null);

  const handleDragStart = () => {
    setDragging(true);
    if (dragTimeoutRef.current) {
      clearTimeout(dragTimeoutRef.current);
    }
  };

  const handleDrag = (e, data, block, setBlockPositions) => {
    const pixelOffset = getPixelOffset();
    const absoluteY = data.y + pixelOffset;

    setBlockPositions((prevPositions) => ({
      ...prevPositions,
      [block._id]: { x: 0, y: absoluteY },
    }));
  };

  const handleDragStop = (e, data, block, setBlockPositions) => {
    const pixelOffset = getPixelOffset();
    const finalY = data.y + pixelOffset;

    // Calculate new start time in minutes
    let newStartMinutes = (finalY / hourHeight) * 60;
    newStartMinutes = roundToNearestInterval(newStartMinutes, snappingIntervalMinutes);

    // Ensure newStartMinutes is within bounds
    const blockDurationMinutes = parseTime(block.endTime) - parseTime(block.startTime);
    newStartMinutes = Math.max(0, Math.min(newStartMinutes, 1440 - blockDurationMinutes));
    const newEndMinutes = newStartMinutes + blockDurationMinutes;

    const newStartTime = formatMinutesToTime(newStartMinutes);
    const newEndTime = formatMinutesToTime(newEndMinutes);

    const updatedBlock = { ...block, startTime: newStartTime, endTime: newEndTime };

    // Notify parent about the move
    onTimeBlockMove(updatedBlock);

    // Calculate snapped absolute Y position
    const snappedY = (newStartMinutes / 60) * hourHeight;

    setBlockPositions((prevPositions) => ({
      ...prevPositions,
      [block._id]: { x: 0, y: snappedY },
    }));

    // Reset dragging state after a short delay
    dragTimeoutRef.current = setTimeout(() => setDragging(false), 200);
  };

  return {
    dragging,
    handleDragStart,
    handleDrag,
    handleDragStop,
  };
};

export default useDragHandlers;


--- Hooks/useFilterBlocks.js ---
// src/hooks/useFilteredBlocks.js

import { useMemo } from 'react';

const validateSelectedDate = (selectedDate) => {
  const dateObj = new Date(selectedDate);
  if (isNaN(dateObj)) {
    console.error(`--> Error: Invalid selectedDate format: ${selectedDate}`);
    return null;
  }
  console.log(`Selected Date Object: ${dateObj} (${dateObj.toISOString()})`);
  return dateObj;
};

const getDayOfWeek = (dateObj) => {
  const dayOfWeek = dateObj.toLocaleDateString('en-US', { weekday: 'long', timeZone: 'Europe/Berlin' });
  console.log(`Day of the Week: ${dayOfWeek}`);
  return dayOfWeek;
};

const isDayEnabled = (blockDatescheme, dayOfWeek, blockIndex) => {
  const daySettings = blockDatescheme[dayOfWeek];
  if (!daySettings) {
    console.warn(`--> Warning: No settings found for ${dayOfWeek} in Block ${blockIndex + 1}.`);
    return false;
  }
  console.log(`Day Settings for ${dayOfWeek}:`, daySettings);
  const enabled = daySettings.enabled ?? false;
  console.log(`Is ${dayOfWeek} Enabled: ${enabled}`);
  return enabled;
};

const isWithinClosingPeriod = (blockDatescheme, selectedDateObj) => {
  console.log(`\n--- Checking Closing Period ---`);
  
  if (!blockDatescheme.closing || !blockDatescheme.closing.enabled) {
    console.log(`--> Closing is not enabled in the block scheme.`);
    return false;
  }
  console.log(`--> Closing is enabled.`);

  const { startDate, endDate } = blockDatescheme.closing;
  console.log(`--> Closing Start Date (raw): ${startDate}`);
  console.log(`--> Closing End Date (raw): ${endDate}`);

  const start = new Date(startDate);
  const end = new Date(endDate);

  if (!isNaN(end)) {
    end.setHours(23, 59, 59, 999);
    console.log(`--> Adjusted Closing End Date to end of day: ${end.toISOString()}`);
  }
  
  if (isNaN(start) || isNaN(end)) {
    console.warn(`--> Warning: Closing period has invalid date(s); unable to check range.`);
    return false;
  }

  const within = selectedDateObj >= start && selectedDateObj <= end;
  console.log(`--> Selected Date: ${selectedDateObj.toISOString()}`);
  console.log(`--> Is Selected Date within Closing Period? ${within}`);
  
  return within;
};

const isWithinPeriod = (blockDatescheme, selectedDateObj) => {
  console.log(`\n--- Checking Period ---`);

  if (!blockDatescheme.period || !blockDatescheme.period.enabled) {
    console.log(`--> Period is not enabled or does not exist in the block scheme.`);
    return true;
  }
  console.log(`--> Period is enabled.`);

  const { startDate, endDate } = blockDatescheme.period;
  console.log(`--> Period Start Date (raw): ${startDate}`);
  console.log(`--> Period End Date (raw): ${endDate}`);

  const start = new Date(startDate);
  const end = new Date(endDate);

  if (!isNaN(end)) {
    end.setHours(23, 59, 59, 999);
    console.log(`--> Adjusted Period End Date to end of day: ${end.toISOString()}`);
  }

  if (isNaN(start) || isNaN(end)) {
    console.warn(`--> Warning: Period has invalid date(s); unable to check range.`);
    return false;
  }

  const within = selectedDateObj >= start && selectedDateObj <= end;
  console.log(`--> Selected Date: ${selectedDateObj.toISOString()}`);
  console.log(`--> Is Selected Date within Period? ${within}`);

  return within;
};

const shouldIncludeBlock = (block, dateKey, selectedDateObj, blockIndex) => {
	const blockDate = block.date;
	const blockDateScheme = block.schemeSettings;
  
	console.log(`\n--- Processing Block ${blockIndex + 1} ---`);
	console.log(`Block Date: ${blockDate}`);
	console.log(`Block scheme Settings:`, blockDateScheme);
  
	if (!blockDateScheme) {
	  console.warn(`--> Warning: block.schemeSettings is undefined for Block ${blockIndex + 1}. Skipping this block.`);
	  return false;
	}
  
	// Check if the block falls within the closing period
	const withinClosing = isWithinClosingPeriod(blockDateScheme, selectedDateObj);
	if (withinClosing) {
	  if (blockDate === dateKey) {
		console.log(`--> Within closing period and block.date matches selectedDate. Adding to blocksForSelectedDate.`);
		return true;
	  } else {
		console.log(`--> Within closing period but block.date does not match selectedDate. Excluding block.`);
		return false;
	  }
	}
  
	const withinPeriod = isWithinPeriod(blockDateScheme, selectedDateObj);
	if (!withinPeriod && blockDate !== dateKey) {
	  console.log(`--> Outside of enabled period and block.date does not match selectedDate. Excluding block.`);
	  return false;
	}
  
	if (blockDate === dateKey) {
	  console.log(`--> Block date matches the selected date. Adding to blocksForSelectedDate.`);
	  block.dayOfWeekBlock = false;
	  return true;
	} else {
	  const dayOfWeek = getDayOfWeek(selectedDateObj);
	  const enabled = isDayEnabled(blockDateScheme, dayOfWeek, blockIndex);
	  if (enabled) {
		console.log(`--> Day is enabled. Setting block times to scheme settings and adding block to blocksForSelectedDate.`);
		
		const daySettings = blockDateScheme[dayOfWeek];
		block.startTime = daySettings.startTime;
		block.endTime = daySettings.endTime;
		block.dayOfWeekBlock = true;
		console.log(`--> Block startTime set to: ${block.startTime}, endTime set to: ${block.endTime}`);
		
		return true;
	  } else {
		console.log(`--> Day is not enabled. Block not added.`);
		return false;
	  }
	}
  };
  
const useFilteredBlocks = (blocks, selectedDate, formatDateKey) => {
  const blocksForSelectedDate = useMemo(() => {
    const dateKey = formatDateKey(selectedDate);
    const filteredBlocks = [];

    console.log(`\n--- Processing Selected Date in useFilteredBlocks ---`);
    console.log(`Selected Date: ${selectedDate}`);
    console.log(`Formatted Date Key: ${dateKey}`);

    const selectedDateObj = validateSelectedDate(selectedDate);
    if (!selectedDateObj) {
      return filteredBlocks;
    }

    for (let i = 0; i < blocks.length; i++) {
      const block = blocks[i];
      const include = shouldIncludeBlock(block, dateKey, selectedDateObj, i);
      if (include) {
        filteredBlocks.push(block);
      }
    }

    console.log(`\n--- Final Blocks for Selected Date in useFilteredBlocks ---`);
    console.log(filteredBlocks);

    return filteredBlocks;
  }, [blocks, selectedDate, formatDateKey]);

  return blocksForSelectedDate;
};

export default useFilteredBlocks;


--- Hooks/useTimeSettings.js ---
// src/components/Timeline/Hooks/useTimelineSettings.js

import { useMemo } from 'react';

const useTimelineSettings = (zoomLevel) => {
  return useMemo(() => {
    let hourInterval;
    let snappingIntervalMinutes;
    if (zoomLevel === 2) {
      hourInterval = 0.25;
      snappingIntervalMinutes = 15;
    } else if (zoomLevel === 1) {
      hourInterval = 0.5;
      snappingIntervalMinutes = 30;
    } else if (zoomLevel === 0.5) {
      hourInterval = 1;
      snappingIntervalMinutes = 60;
    } else if (zoomLevel === 0.25) {
      hourInterval = 2;
      snappingIntervalMinutes = 120;
    } else {
      hourInterval = 1;
      snappingIntervalMinutes = 60;
    }

    const hours = [];
    for (let i = 0; i <= 24; i += hourInterval) {
      hours.push(i);
    }

    return { hourInterval, snappingIntervalMinutes, hours };
  }, [zoomLevel]);
};

export default useTimelineSettings;


--- Modal/Exceptions/ExceptionItems.js ---
// src/components/Modal/ExceptionItem.jsx

import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';

const formatDateDutch = (date) => {
	if (!date) return '';

	const months = [
	  'januari',
	  'februari',
	  'maart',
	  'april',
	  'mei',
	  'juni',
	  'juli',
	  'augustus',
	  'september',
	  'oktober',
	  'november',
	  'december',
	];
  
	const dayNumber = date.getDate();
	const monthName = months[date.getMonth()];
	const year = date.getFullYear();
  
	return `${dayNumber} ${monthName} ${year}`;
  };
  

  const ExceptionItem = ({
	type,
	item,
	index,
	handleToggle,
	handleInputChange,
  }) => {
  
	// Determine the label based on the type and selected dates
	let label = '';
	if (type === 'sluitingsperiode') {
	  if (item.startDate && item.endDate) {
		label = `${formatDateDutch(new Date(item.startDate))} - ${formatDateDutch(
		  new Date(item.endDate)
		)}`;
	  } else {
		label = `Periode ${index + 1}`;
	  }
	} else if (type === 'sluitingsdag') {
	  if (item.date) {
		label = `${formatDateDutch(new Date(item.date))}`;
	  } else {
		label = `Dag ${index + 1}`;
	  }
	} else if (type === 'uitzonderlijkeOpeningsuren') {
	  if (item.date && item.startTime && item.endTime) {
		label = `${formatDateDutch(new Date(item.date))} - (${item.startTime} - ${item.endTime})`;
	  } else {
		label = `Uur ${index + 1}`;
	  }
	}
  
	return (
	  <div className="exceptional-day-item">
		<div className="day-header">
		  <span className={`day-label ${!item.enabled ? 'disabled' : ''}`}>
			{label}
		  </span>
		  <label className="switch">
			<input
			  type="checkbox"
			  checked={item.enabled}
			  onChange={() => handleToggle(type, index)}
			/>
			<span className="slider round"></span>
		  </label>
		</div>
		<AnimatePresence>
		  {item.enabled && (
			<motion.div
			  className="inputs-container"
			  initial={{ height: 0, opacity: 0 }}
			  animate={{ height: 'auto', opacity: 1 }}
			  exit={{ height: 0, opacity: 0 }}
			  transition={{ duration: 0.3 }}
			  layout
			>
			  {type === 'sluitingsperiode' && (
				<>
				  <label className="modal-label date-input">
					Start datum:
					<input
					  type="date"
					  value={item.startDate}
					  onChange={(e) =>
						handleInputChange(
						  type,
						  index,
						  'startDate',
						  e.target.value
						)
					  }
					  required
					/>
				  </label>
				  <label className="modal-label date-input">
					Eind datum:
					<input
					  type="date"
					  value={item.endDate}
					  onChange={(e) =>
						handleInputChange(
						  type,
						  index,
						  'endDate',
						  e.target.value
						)
					  }
					  required
					/>
				  </label>
				</>
			  )}
			  {type === 'sluitingsdag' && (
				<label className="modal-label date-input">
				  Datum:
				  <input
					type="date"
					value={item.date}
					onChange={(e) =>
					  handleInputChange(type, index, 'date', e.target.value)
					}
					required
				  />
				</label>
			  )}
			  {type === 'uitzonderlijkeOpeningsuren' && (
				<>
				  <label className="modal-label date-input">
					Datum:
					<input
					  type="date"
					  value={item.date}
					  onChange={(e) =>
						handleInputChange(type, index, 'date', e.target.value)
					  }
					  required
					/>
				  </label>
				  <label className="modal-label time-input">
					Start tijd:
					<input
					  type="time"
					  value={item.startTime}
					  onChange={(e) =>
						handleInputChange(
						  type,
						  index,
						  'startTime',
						  e.target.value
						)
					  }
					  required
					/>
				  </label>
				  <label className="modal-label time-input">
					Eindtijd:
					<input
					  type="time"
					  value={item.endTime}
					  onChange={(e) =>
						handleInputChange(
						  type,
						  index,
						  'endTime',
						  e.target.value
						)
					  }
					  required
					/>
				  </label>
				</>
			  )}
			</motion.div>
		  )}
		</AnimatePresence>
	  </div>
	);
  };
  
  export default ExceptionItem;

--- Modal/Exceptions/Exceptions.js ---
// src/components/Modal/ExceptionalDays.jsx

import React from 'react';
import ExceptionItem from './ExceptionItems'; // Corrected import path
import './css/exceptions.css';

const ExceptionalDays = ({
  exceptionalDays,
  setExceptionalDays,
  onSaveExceptionalDays,
}) => {
  const handleToggle = (type, index) => {
    setExceptionalDays((prev) => {
      const updatedList = prev[type].map((item, i) =>
        i === index ? { ...item, enabled: !item.enabled } : item
      );
      return { ...prev, [type]: updatedList };
    });
  };

  const handleInputChange = (type, index, field, value) => {
    setExceptionalDays((prev) => {
      const updatedList = prev[type].map((item, i) =>
        i === index ? { ...item, [field]: value } : item
      );
      return { ...prev, [type]: updatedList };
    });
  };

  const addNewException = (type) => {
    setExceptionalDays((prev) => {
      const newException = { enabled: false };
      if (type === 'sluitingsperiode') {
        newException.startDate = '';
        newException.endDate = '';
      } else if (type === 'sluitingsdag') {
        newException.date = '';
      } else if (type === 'uitzonderlijkeOpeningsuren') {
        newException.date = '';
        newException.startTime = '';
        newException.endTime = '';
      }
      return {
        ...prev,
        [type]: [...prev[type], newException],
      };
    });
  };

  return (
    <div>
      <h2 className="secondary-title">Sluitingsdagen</h2>

      {/* Sluitingsperiode Section */}
      <div className="exception-type-section">
        <h3>Sluitingsperiode</h3>
        {exceptionalDays.sluitingsperiode.map((item, index) => (
          <ExceptionItem
            key={index}
            type="sluitingsperiode"
            item={item}
            index={index}
            handleToggle={handleToggle}
            handleInputChange={handleInputChange}
          />
        ))}
        <button
          type="button"
          className="add-exception-button"
          onClick={() => addNewException('sluitingsperiode')}
        >
          + Voeg Sluitingsperiode Toe
        </button>
      </div>

      {/* Sluitingsdag Section */}
      <div className="exception-type-section">
        <h3>Sluitingsdag</h3>
        {exceptionalDays.sluitingsdag.map((item, index) => (
          <ExceptionItem
            key={index}
            type="sluitingsdag"
            item={item}
            index={index}
            handleToggle={handleToggle}
            handleInputChange={handleInputChange}
          />
        ))}
        <button
          type="button"
          className="add-exception-button"
          onClick={() => addNewException('sluitingsdag')}
        >
          + Voeg Sluitingsdag Toe
        </button>
      </div>

      {/* Uitzonderlijke Openingsuren Section */}
      <div className="exception-type-section">
        <h3>Uitzonderlijke Openingsuren</h3>
        {exceptionalDays.uitzonderlijkeOpeningsuren.map((item, index) => (
          <ExceptionItem
            key={index}
            type="uitzonderlijkeOpeningsuren"
            item={item}
            index={index}
            handleToggle={handleToggle}
            handleInputChange={handleInputChange}
          />
        ))}
        <button
          type="button"
          className="add-exception-button"
          onClick={() => addNewException('uitzonderlijkeOpeningsuren')}
        >
          + Voeg Uitzonderlijke Openingsuren Toe
        </button>
      </div>

      <div className="modal-buttons">
        <button
          type="button"
          className="standard-button blue"
          onClick={onSaveExceptionalDays}
        >
          Opslaan
        </button>
      </div>
    </div>
  );
};

export default ExceptionalDays;


--- Modal/Hooks/useSchemeValidation.js ---
import { useState } from 'react';

const useSchemeValidation = (items, schemeSettings) => {
  const [errors, setErrors] = useState({});

  const validate = () => {
    // Initialize an empty errors object
    const newErrors = {};

    items.forEach((item) => {
      const settings = schemeSettings[item.id];
      if (settings?.enabled) {
        const itemErrors = [];

        if (item.type === 'day') {
          const { startTime, endTime, shiftsEnabled, shifts = [] } = settings;

          // Validate startTime and endTime
          if (!startTime || !endTime) {
            itemErrors.push('Start tijd en eindtijd moeten ingevuld zijn.');
          } else if (startTime >= endTime) {
            itemErrors.push('Start tijd moet voor eindtijd zijn.');
          }

          // Validate that shifts are provided if shiftsEnabled is true
          if (shiftsEnabled) {
            if (!shifts || shifts.length === 0) {
              itemErrors.push('Er moeten minimaal één shift worden gedefinieerd wanneer shifts zijn ingeschakeld.');
            } else {
              shifts.forEach((shift, index) => {
                const shiftErrors = [];

                // Validate shift name
                if (!shift.name) {
                  shiftErrors.push('Shift naam moet ingevuld zijn.');
                }

                // Validate shift startTime
                if (!shift.startTime) {
                  shiftErrors.push('Shift start tijd moet ingevuld zijn.');
                }

                // Validate shift startTime within day's startTime and endTime
                if (shift.startTime && startTime && endTime) {
                  if (shift.startTime < startTime || shift.startTime > endTime) {
                    shiftErrors.push('Shift start tijd moet binnen de openingsuren vallen.');
                  }
                }

                // If there are errors for this shift, add them to newErrors
                if (shiftErrors.length > 0) {
                  newErrors[`${item.id}.shifts.${index}`] = shiftErrors;
                }
              });
            }
          }
        } else if (item.type === 'duration') {
          const { startDate, endDate } = settings;

          // Validate startDate and endDate
          if (!startDate || !endDate) {
            itemErrors.push('Start datum en einddatum moeten ingevuld zijn.');
          } else if (new Date(startDate) > new Date(endDate)) {
            itemErrors.push('Start datum moet voor einddatum zijn.');
          }
        }

        // If there are errors for this item, add them to newErrors
        if (itemErrors.length > 0) {
          newErrors[item.id] = itemErrors;
        }
      }
    });

    // Update the errors state with new errors
    setErrors(newErrors);

    // Return true if there are no errors
    return Object.keys(newErrors).length === 0;
  };

  return { errors, validate };
};

export default useSchemeValidation;


--- Modal/ModalContent.js ---
// src/components/Modal/ModalContent.jsx

import React, { useState, useEffect } from 'react';
import './css/modalContent.css';
import { FaCalendarWeek } from 'react-icons/fa';

const ModalContent = ({
  formData,
  setFormData,
  onSave,
  onDelete,
  existingBlock,
  selectedDate,
}) => {
  const [showMessage, setShowMessage] = useState(true);

  useEffect(() => {
    const isMessageHidden = localStorage.getItem('hideWeeklyScheduleMessage');
    if (isMessageHidden === 'true') {
      setShowMessage(false);
    }
  }, []);

  const formatDateDutch = (date) => {
    const months = [
      'januari', 'februari', 'maart', 'april', 'mei', 'juni',
      'juli', 'augustus', 'september', 'oktober', 'november', 'december'
    ];
    const day = date.getDate();
    const month = months[date.getMonth()];
    return `${day} ${month}`;
  };

  const handleSubmit = (e, continueToSettings = false) => {
    e.preventDefault();
    onSave(continueToSettings);
  };

  const handleDelete = () => {
    onDelete();
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    const newValue = name === 'zitplaatsen' ? Number(value) : value;
    setFormData((prev) => ({
      ...prev,
      [name]: newValue,
    }));
  };

  const handleCloseMessage = () => {
    setShowMessage(false);
  };

  const handlePermanentCloseMessage = () => {
    setShowMessage(false);
    localStorage.setItem('hideWeeklyScheduleMessage', 'true');
  };

  return (
    <>
      <h2 className="secondary-title">
        {existingBlock ? 'Tijdsblok Bewerken' : 'Tijdsblok Toevoegen'}
      </h2>

      <form onSubmit={(e) => handleSubmit(e, false)}>
        <label className="modal-label">
          Titel:
          <input
            type="text"
            name="title"
            value={formData.title}
            onChange={handleChange}
            required
          />
        </label>
        <div className="time-inputs-container">
          <label className="modal-label time-input">
            Start:
            <input
              type="time"
              name="startTime"
              value={formData.startTime}
              onChange={handleChange}
              required
            />
          </label>
          <label className="modal-label time-input">
            Einde:
            <input
              type="time"
              name="endTime"
              value={formData.endTime}
              onChange={handleChange}
              required
            />
          </label>
        </div>
        <label className="modal-label">
          Max Capaciteit Gasten:
          <input
            type="number"
            name="zitplaatsen"
            value={formData.zitplaatsen}
            onChange={handleChange}
            min="1"
            required
          />
        </label>
        <label className="modal-label">
          Kleur:
          <input
            type="color"
            name="kleurInstelling"
            value={formData.kleurInstelling}
            onChange={handleChange}
            required
          />
        </label>
        
        {showMessage && (
          <div className="weekly-schedule-container">
            <FaCalendarWeek className="weekly-schedule-icon" />
            <div className="weekly-schedule-message">
              <span>
                <strong>Bovenstaande instellingen betreffen het huidige tijdsblok.</strong> U kunt een tijdsblok herhalen en openingsuren instellen in Schema.
              </span>
              <span className="close-message" onClick={handleCloseMessage}>
                Verbergen
              </span>
              <span className="close-message left-margin" onClick={handlePermanentCloseMessage}>
                Sluiten
              </span>
            </div>
          </div>
        )}

        <div className="modal-buttons">
          {existingBlock && (
            <button
              type="button"
              className="standard-button red spaced"
              onClick={handleDelete}
            >
              Verwijderen
            </button>
          )}
          <button
            type="button"
            className="standard-button blue spaced"
            onClick={(e) => handleSubmit(e, true)}
          >
            Opslaan
          </button>
        </div>
      </form>
    </>
  );
};

export default ModalContent;


--- Modal/Scheme/SchemeItem.js ---
// SchemeItem.jsx

import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { FaChevronDown } from 'react-icons/fa';
import Shifts from './Shifts';
import ToggleSwitch from './ToggleSwitch';

const SchemeItem = ({
  item,
  schemeSettings,
  handleToggle,
  handleInputChange,
  errors,
  isSaveAttempted,
  handleShiftsToggle,
  handleShiftInputChange,
  addShift,
  removeShift,
}) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const enabled = schemeSettings[item.id]?.enabled || false;

  // Expand when enabled is set to true
  useEffect(() => {
    if (enabled) {
      setIsExpanded(true);
    } else {
      setIsExpanded(false);
    }
  }, [enabled]);

  return (
    <div
      key={item.id}
      className={`scheme-item ${item.type !== 'day' ? 'scheme-item-special' : ''}`}
    >
      {/* Make the whole header clickable */}
      <div
        className={`item-header ${isExpanded ? 'expanded' : ''}`}
        onClick={enabled ? () => setIsExpanded(!isExpanded) : null}
      >
        <div className={`item-label ${!enabled ? 'disabled' : ''}`}>
          {/* Conditionally render the chevron icon when enabled */}
          {enabled && (
            <FaChevronDown className={`arrow-icon ${isExpanded ? 'expanded' : ''}`} />
          )}
          {item.label}
        </div>
        {/* ToggleSwitch remains on the right and stops event propagation */}
        <div className="toggle-middle" onClick={(e) => e.stopPropagation()}>
          <ToggleSwitch checked={enabled} onChange={() => handleToggle(item.id)} />
        </div>
      </div>

      <AnimatePresence>
        {isExpanded && enabled && (
          <motion.div
            className="item-content"
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.3 }}
            layout
          >
            {item.type === 'day' ? (
              <>
                <label className="modal-label time-input">
                  Start tijd:
                  <input
                    type="time"
                    name={`startTime-${item.id}`}
                    value={schemeSettings[item.id]?.startTime || ''}
                    onChange={(e) =>
                      handleInputChange(item.id, 'startTime', e.target.value)
                    }
                    required
                  />
                </label>
                <label className="modal-label time-input">
                  Eindtijd:
                  <input
                    type="time"
                    name={`endTime-${item.id}`}
                    value={schemeSettings[item.id]?.endTime || ''}
                    onChange={(e) =>
                      handleInputChange(item.id, 'endTime', e.target.value)
                    }
                    required
                  />
                </label>
                {isSaveAttempted &&
                  errors[item.id] &&
                  Object.values(errors[item.id])
                    .filter((error) => typeof error === 'string')
                    .map((errorMsg, index) => (
                      <span key={index} className="error-shifts">
                        {errorMsg}
                      </span>
                    ))}
              </>
            ) : (
              <>
                <label className="modal-label date-input">
                  Start datum:
                  <input
                    type="date"
                    name={`startDate-${item.id}`}
                    value={schemeSettings[item.id]?.startDate || ''}
                    onChange={(e) =>
                      handleInputChange(item.id, 'startDate', e.target.value)
                    }
                    required
                  />
                </label>
                <label className="modal-label date-input">
                  Eind datum:
                  <input
                    type="date"
                    name={`endDate-${item.id}`}
                    value={schemeSettings[item.id]?.endDate || ''}
                    onChange={(e) =>
                      handleInputChange(item.id, 'endDate', e.target.value)
                    }
                    required
                  />
                </label>
                {isSaveAttempted &&
                  errors[item.id] &&
                  Object.values(errors[item.id]).map((errorMsg, index) => (
                    <span key={index} className="error-shifts">
                      {errorMsg}
                    </span>
                  ))}
              </>
            )}

            {/* Render Shifts component if enabled and item type is 'day' */}
            {item.type === 'day' && (
              <Shifts
                itemId={item.id}
                schemeSettings={schemeSettings}
                handleShiftsToggle={handleShiftsToggle}
                handleShiftInputChange={handleShiftInputChange}
                addShift={addShift}
                removeShift={removeShift}
                errors={errors[item.id]?.shifts}
                isSaveAttempted={isSaveAttempted}
              />
            )}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default SchemeItem;


--- Modal/Scheme/ShiftItem.js ---
import React from 'react';
import { FaTrash } from 'react-icons/fa'; // Import the FaTrash icon

const ShiftItem = ({
  shift,
  shiftIndex,
  itemId,
  handleShiftInputChange,
  removeShift,
  errors,
  isSaveAttempted,
}) => (
  <div className="shift-item shift-item-box">
    {/* Shift Inputs Grid */}
    <div className="shift-inputs-grid">
      {/* Start Time Input */}
      <label className="modal-label shift-input">
        Start tijd:
        <input
          type="time"
          name={`shiftStartTime-${itemId}-${shiftIndex}`}
          value={shift.startTime}
          onChange={(e) =>
            handleShiftInputChange(itemId, shiftIndex, 'startTime', e.target.value)
          }
          required
        />
        {isSaveAttempted && errors?.startTime && (
          <span className="error-shifts">{errors.startTime}</span>
        )}
        {isSaveAttempted && errors?.startTimeRange && (
          <span className="error-shifts">{errors.startTimeRange}</span>
        )}
      </label>

      {/* Shift Name Input */}
      <label className="modal-label shift-input">
        Shift naam:
        <input
          type="text"
          name={`shiftName-${itemId}-${shiftIndex}`}
          value={shift.name}
          onChange={(e) =>
            handleShiftInputChange(itemId, shiftIndex, 'name', e.target.value)
          }
          required
        />
        {isSaveAttempted && errors?.name && (
          <span className="error-shifts">{errors.name}</span>
        )}
      </label>

      {/* Remove Shift Button with FaTrash Icon */}
      <button
        type="button"
        className="remove-shift-button"
        onClick={() => removeShift(itemId, shiftIndex)}
        aria-label="Verwijder Shift" // Accessibility label
      >
        <FaTrash />
      </button>
    </div>
  </div>
);

export default ShiftItem;


--- Modal/Scheme/Shifts.js ---
import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ShiftItem from './ShiftItem';
import ToggleSwitch from './ToggleSwitch';

const Shifts = ({
  itemId,
  schemeSettings,
  handleShiftsToggle,
  handleShiftInputChange,
  addShift,
  removeShift,
  errors,
  isSaveAttempted,
}) => {
  const shiftsEnabled = schemeSettings[itemId]?.shiftsEnabled || false;
  const shifts = schemeSettings[itemId]?.shifts || [];

  return (
    <>
      <ToggleSwitch
        checked={shiftsEnabled}
        onChange={() => handleShiftsToggle(itemId)}
        label="Shifts aanzetten"
        className="shifts-header"
      />

      <AnimatePresence>
        {shiftsEnabled && (
          <motion.div
            className="shifts-container"
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.3 }}
            layout
          >
            {shifts.map((shift, shiftIndex) => (
              <ShiftItem
                key={shiftIndex}
                shift={shift}
                shiftIndex={shiftIndex}
                itemId={itemId}
                handleShiftInputChange={handleShiftInputChange}
                removeShift={removeShift}
                errors={errors ? errors[shiftIndex] : {}}
                isSaveAttempted={isSaveAttempted}
              />
            ))}

            {/* Add Shift Button */}
            <button
              type="button"
              className="add-shift-button"
              onClick={() => addShift(itemId)}
            >
              + Voeg Shift Toe
            </button>
          </motion.div>
        )}
      </AnimatePresence>
    </>
  );
};

export default Shifts;


--- Modal/Scheme/ToggleSwitch.js ---
// ToggleSwitch.jsx

import React from 'react';
import PropTypes from 'prop-types';

const ToggleSwitch = ({ checked, onChange, label, className }) => (
  <div className={`day-header ${className || ''}`}>
    <span className="day-label">{label}</span>
    <label className="switch" aria-label={label}>
      <input
        type="checkbox"
        checked={checked}
        onChange={onChange}
        aria-checked={checked}
        aria-labelledby={`${label}-toggle`}
      />
      <span className="slider round"></span>
    </label>
  </div>
);

ToggleSwitch.propTypes = {
  checked: PropTypes.bool.isRequired,
  onChange: PropTypes.func.isRequired,
  label: PropTypes.string.isRequired,
  className: PropTypes.string,
};

ToggleSwitch.defaultProps = {
  className: '',
};

export default ToggleSwitch;


--- Modal/Scheme/index.js ---
// Scheme.jsx

import React, { useState } from 'react';
import './css/scheme.css';
import useSchemeValidation from '../Hooks/useSchemeValidation'; // Import the custom hook
import SchemeItem from './SchemeItem';

const Scheme = ({
  schemeSettings,
  setschemeSettings,
  onSaveScheme,
  onDeleteScheme,
  defaultStartTime,
  defaultEndTime,
  triggerNotification,
}) => {
  const items = [
    { id: 'Monday', label: 'Maandag', type: 'day' },
    { id: 'Tuesday', label: 'Dinsdag', type: 'day' },
    { id: 'Wednesday', label: 'Woensdag', type: 'day' },
    { id: 'Thursday', label: 'Donderdag', type: 'day' },
    { id: 'Friday', label: 'Vrijdag', type: 'day' },
    { id: 'Saturday', label: 'Zaterdag', type: 'day' },
    { id: 'Sunday', label: 'Zondag', type: 'day' },
    { id: 'period', label: 'Herhalen voor Beperkte Periode', type: 'duration' },
  ];

  const [isSaveAttempted, setIsSaveAttempted] = useState(false);
  const { errors, validate } = useSchemeValidation(items, schemeSettings);

  const handleToggle = (itemId) => {
    setschemeSettings((prev) => {
      const isEnabled = prev[itemId]?.enabled;
      if (!isEnabled) {
        return {
          ...prev,
          [itemId]: {
            enabled: true,
            startTime:
              prev[itemId]?.startTime ||
              (items.find((item) => item.id === itemId).type === 'day'
                ? defaultStartTime
                : ''),
            endTime:
              prev[itemId]?.endTime ||
              (items.find((item) => item.id === itemId).type === 'day'
                ? defaultEndTime
                : ''),
            startDate: prev[itemId]?.startDate || '',
            endDate: prev[itemId]?.endDate || '',
            shiftsEnabled: false,
            shifts: [],
          },
        };
      } else {
        const { [itemId]: removed, ...rest } = prev;
        return rest;
      }
    });
  };

  const handleShiftsToggle = (itemId) => {
    setschemeSettings((prev) => ({
      ...prev,
      [itemId]: {
        ...prev[itemId],
        shiftsEnabled: !prev[itemId]?.shiftsEnabled,
        shifts: !prev[itemId]?.shiftsEnabled ? [] : prev[itemId].shifts,
      },
    }));
  };

  const handleInputChange = (itemId, field, value) => {
    setschemeSettings((prev) => ({
      ...prev,
      [itemId]: {
        ...prev[itemId],
        [field]: value,
      },
    }));
  };

  const handleShiftInputChange = (itemId, shiftIndex, field, value) => {
    setschemeSettings((prev) => {
      const shifts = [...(prev[itemId]?.shifts || [])];
      shifts[shiftIndex] = {
        ...shifts[shiftIndex],
        [field]: value,
      };
      return {
        ...prev,
        [itemId]: {
          ...prev[itemId],
          shifts,
        },
      };
    });
  };

  const addShift = (itemId) => {
    setschemeSettings((prev) => {
      const shifts = [...(prev[itemId]?.shifts || [])];
      shifts.push({
        name: '',
        startTime: '',
      });
      return {
        ...prev,
        [itemId]: {
          ...prev[itemId],
          shifts,
        },
      };
    });
  };

  const removeShift = (itemId, shiftIndex) => {
    setschemeSettings((prev) => {
      const shifts = [...(prev[itemId]?.shifts || [])];
      shifts.splice(shiftIndex, 1);
      return {
        ...prev,
        [itemId]: {
          ...prev[itemId],
          shifts,
        },
      };
    });
  };

  const handleSaveScheme = () => {
    setIsSaveAttempted(true);
    if (validate()) {
      onSaveScheme();
    } else {
      triggerNotification('Controleer de invulvelden', 'warning');
    }
  };

  return (
    <div>
      <h2 className="secondary-title">Openingsuren</h2>
      <div className="scheme-list">
        {items.map((item) => (
          <SchemeItem
            key={item.id}
            item={item}
            schemeSettings={schemeSettings}
            handleToggle={handleToggle}
            handleInputChange={handleInputChange}
            errors={errors}
            isSaveAttempted={isSaveAttempted}
            handleShiftsToggle={handleShiftsToggle}
            handleShiftInputChange={handleShiftInputChange}
            addShift={addShift}
            removeShift={removeShift}
          />
        ))}
      </div>
      <div className="modal-buttons">
        <button
          type="button"
          className="standard-button blue"
          onClick={handleSaveScheme}
        >
          Opslaan
        </button>
      </div>
    </div>
  );
};

export default Scheme;


--- Modal/index.js ---
// src/components/Modal/index.js

import React, { useState, useEffect } from 'react';
import ModalWithTabs from '../../../Components/Structural/Modal/WithTabs';
import ModalContent from './ModalContent';
import Scheme from './Scheme';
import ExceptionalDays from './Exceptions/Exceptions';
import { formatDateKey } from '../Utils/dateFormat';

const Modal = ({ onClose, onSave, onDelete, existingBlock, selectedDate, triggerNotification }) => {
  const [schemeSettings, setschemeSettings] = useState(
    existingBlock?.schemeSettings || {}
  );

  const [exceptionalDays, setExceptionalDays] = useState(
    existingBlock?.exceptionalDays || {
      sluitingsperiode: [],
      sluitingsdag: [],
      uitzonderlijkeOpeningsuren: [],
    }
  );

  const formatDateDutch = (date) => {
    const months = [
      'januari',
      'februari',
      'maart',
      'april',
      'mei',
      'juni',
      'juli',
      'augustus',
      'september',
      'oktober',
      'november',
      'december',
    ];
    const day = date.getDate();
    const month = months[date.getMonth()];
    return `${day} ${month}`;
  };

  const [formData, setFormData] = useState({
    title: existingBlock
      ? existingBlock.title
      : `Tijdsblok (${formatDateDutch(selectedDate)})`,
    startTime: existingBlock ? existingBlock.startTime : '17:00',
    endTime: existingBlock ? existingBlock.endTime : '23:00',
    kleurInstelling: existingBlock ? existingBlock.kleurInstelling : '#2c909b',
    zitplaatsen: existingBlock ? existingBlock.zitplaatsen : 1,
  });

  useEffect(() => {
    document.body.style.overflow = 'hidden';
    return () => {
      document.body.style.overflow = 'auto';
    };
  }, []);

  const handleSave = (continueToSettings = false) => {
    if (formData.zitplaatsen < 1) {
      alert('Zitplaatsen moet een positief getal zijn.');
      return;
    }

    const newBlock = {
      id: existingBlock ? existingBlock._id : undefined,
      _id: existingBlock ? existingBlock._id : undefined,
      date: formatDateKey(selectedDate),
      ...formData,
      schemeSettings,
      exceptionalDays,
    };
    onSave(newBlock, continueToSettings);
  };

  const handleDelete = () => {
    onDelete(existingBlock);
  };

  const handleSaveSchema = () => {
    handleSave();
  };

  const handleSaveExceptionalDays = () => {
    handleSave();
  };

  const tabs = [
    {
      id: 'algemeen',
      label: 'Tijdsblok',
      content: (
        <ModalContent
          formData={formData}
          setFormData={setFormData}
          onSave={handleSave}
          onDelete={handleDelete}
          existingBlock={existingBlock}
          selectedDate={selectedDate}
        />
      ),
    },
    {
      id: 'schema',
      label: 'Schema',
      content: (
        <Scheme
          schemeSettings={schemeSettings}
          setschemeSettings={setschemeSettings}
          onSaveScheme={handleSaveSchema}
          triggerNotification={triggerNotification}
        />
      ),
    },
    {
      id: 'uitzonderingen',
      label: 'Uitzonderingen',
      content: (
        <ExceptionalDays
          exceptionalDays={exceptionalDays}
          setExceptionalDays={setExceptionalDays}
          onSaveExceptionalDays={handleSaveExceptionalDays}
        />
      ),
    },
  ];

  return <ModalWithTabs tabs={tabs} onClose={onClose} />;
};

export default Modal;


--- SchemeStandalone.js ---
// src/components/SchemeStandalone.jsx

import React, { useState, useEffect } from 'react';
import useSchemeValidation from './Modal/Hooks/useSchemeValidation';
import SchemeItem from './Modal/Scheme/SchemeItem';
import useTimeBlocks from './Hooks/fetchTimeblocks';
import useNotification from '../../Components/Notification/index';
import { withHeader } from '../../Components/Structural/Header';

const SchemeStandalone = () => {
  const { triggerNotification, NotificationComponent } = useNotification();
  const { blocks, updateTimeBlock } = useTimeBlocks(triggerNotification);
  const [schemeSettings, setschemeSettings] = useState(null);
  const [timeBlockId, setTimeBlockId] = useState(null);
  const [defaultStartTime, setDefaultStartTime] = useState('17:00');
  const [defaultEndTime, setDefaultEndTime] = useState('23:00');

  useEffect(() => {
    if (blocks && blocks.length > 0) {
      const firstBlockWithScheme = blocks.find((block) => block.schemeSettings);
      if (firstBlockWithScheme) {
        setschemeSettings(firstBlockWithScheme.schemeSettings);
        setTimeBlockId(firstBlockWithScheme._id);
        setDefaultStartTime(firstBlockWithScheme.startTime || '17:00');
        setDefaultEndTime(firstBlockWithScheme.endTime || '23:00');
      }
    }
  }, [blocks]);

  const items = [
    { id: 'Monday', label: 'Maandag', type: 'day' },
    { id: 'Tuesday', label: 'Dinsdag', type: 'day' },
    { id: 'Wednesday', label: 'Woensdag', type: 'day' },
    { id: 'Thursday', label: 'Donderdag', type: 'day' },
    { id: 'Friday', label: 'Vrijdag', type: 'day' },
    { id: 'Saturday', label: 'Zaterdag', type: 'day' },
    { id: 'Sunday', label: 'Zondag', type: 'day' },
    { id: 'period', label: 'Herhalen voor Beperkte Periode', type: 'duration' },
  ];

  const [isSaveAttempted, setIsSaveAttempted] = useState(false);
  const { errors, validate } = useSchemeValidation(items, schemeSettings);

  const handleToggle = (itemId) => {
    setschemeSettings((prev) => {
      const isEnabled = prev[itemId]?.enabled;
      if (!isEnabled) {
        return {
          ...prev,
          [itemId]: {
            enabled: true,
            startTime:
              prev[itemId]?.startTime ||
              (items.find((item) => item.id === itemId).type === 'day'
                ? defaultStartTime
                : ''),
            endTime:
              prev[itemId]?.endTime ||
              (items.find((item) => item.id === itemId).type === 'day'
                ? defaultEndTime
                : ''),
            startDate: prev[itemId]?.startDate || '',
            endDate: prev[itemId]?.endDate || '',
            shiftsEnabled: false,
            shifts: [],
          },
        };
      } else {
        const { [itemId]: removed, ...rest } = prev;
        return rest;
      }
    });
  };

  const handleShiftsToggle = (itemId) => {
    setschemeSettings((prev) => ({
      ...prev,
      [itemId]: {
        ...prev[itemId],
        shiftsEnabled: !prev[itemId]?.shiftsEnabled,
        shifts: !prev[itemId]?.shiftsEnabled ? [] : prev[itemId].shifts,
      },
    }));
  };

  const handleInputChange = (itemId, field, value) => {
    setschemeSettings((prev) => ({
      ...prev,
      [itemId]: {
        ...prev[itemId],
        [field]: value,
      },
    }));
  };

  const handleShiftInputChange = (itemId, shiftIndex, field, value) => {
    setschemeSettings((prev) => {
      const shifts = [...(prev[itemId]?.shifts || [])];
      shifts[shiftIndex] = {
        ...shifts[shiftIndex],
        [field]: value,
      };
      return {
        ...prev,
        [itemId]: {
          ...prev[itemId],
          shifts,
        },
      };
    });
  };

  const addShift = (itemId) => {
    setschemeSettings((prev) => {
      const shifts = [...(prev[itemId]?.shifts || [])];
      shifts.push({
        name: '',
        startTime: '',
      });
      return {
        ...prev,
        [itemId]: {
          ...prev[itemId],
          shifts,
        },
      };
    });
  };

  const removeShift = (itemId, shiftIndex) => {
    setschemeSettings((prev) => {
      const shifts = [...(prev[itemId]?.shifts || [])];
      shifts.splice(shiftIndex, 1);
      return {
        ...prev,
        [itemId]: {
          ...prev[itemId],
          shifts,
        },
      };
    });
  };

  const handleSaveScheme = async () => {
    setIsSaveAttempted(true);
    if (validate()) {
      if (timeBlockId) {
        const blockToUpdate = blocks.find((block) => block._id === timeBlockId);
        if (blockToUpdate) {
          const updatedBlock = {
            ...blockToUpdate,
            schemeSettings,
          };
          try {
            await updateTimeBlock(updatedBlock);
            triggerNotification('Schema opgeslagen', 'success');
          } catch (err) {
            triggerNotification('Fout bij het opslaan van het schema', 'error');
          }
        }
      } else {
        triggerNotification('Geen tijdsblok gevonden om het schema op te slaan', 'warning');
      }
    } else {
      triggerNotification('Controleer de invulvelden', 'warning');
    }
  };

  if (!schemeSettings) {
    return <div>Geen schema gevonden.</div>;
  }

  return (
    <div className='scheme-page'>
    <div className='day-calendar-page'>

      <div className='scheme-container'>
      <NotificationComponent />
      <h2 className="secondary-title">Openingsuren</h2>
      <div className="scheme-list">
        {items.map((item) => (
          <SchemeItem
            key={item.id}
            item={item}
            schemeSettings={schemeSettings}
            handleToggle={handleToggle}
            handleInputChange={handleInputChange}
            errors={errors}
            isSaveAttempted={isSaveAttempted}
            handleShiftsToggle={handleShiftsToggle}
            handleShiftInputChange={handleShiftInputChange}
            addShift={addShift}
            removeShift={removeShift}
          />
        ))}
      </div>
      <div className="modal-buttons">
        <button
          type="button"
          className="standard-button blue"
          onClick={handleSaveScheme}
        >
          Opslaan
        </button>
      </div>
      </div>
    </div>
    </div>
  );
};

export default withHeader(SchemeStandalone);


--- Utils/constants.js ---
// constants.js

export const shifts = {
	Ochtend: { start: '07:00', end: '11:00' },
	Middag: { start: '11:00', end: '16:00' },
	Avond: { start: '17:00', end: '23:00' },
	'Volledig Dag': { start: '00:00', end: '23:59' },
  };
  

--- Utils/dateFormat.js ---
export const formatDateKey = (date) => {
	const year = date.getFullYear();
	const month = String(date.getMonth() + 1).padStart(2, '0');
	const day = String(date.getDate()).padStart(2, '0');
	return `${year}-${month}-${day}`;
  };

--- Utils/timeUtils.js ---
// src/utils/timeUtils.js

export const parseTime = (timeString) => {
	const [hours, minutes] = timeString.split(':').map(Number);
	return hours * 60 + minutes;
  };
  
  export const formatMinutesToTime = (totalMinutes) => {
	let hours = Math.floor(totalMinutes / 60);
	let minutes = totalMinutes % 60;
  
	if (hours >= 24) {
	  hours = 23;
	  minutes = 59;
	} else if (hours < 0) {
	  hours = 0;
	  minutes = 0;
	}
  
	return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
  };
  
  export const roundToNearestInterval = (minutes, interval) => {
	return Math.round(minutes / interval) * interval;
  };
  

--- index.js ---
// src/components/DayCalendar.js

import React, { useState, useEffect } from 'react';
import { withHeader } from '../../Components/Structural/Header/index.js';
import Timeline from './time.js'; // Updated import (ensure the path is correct)
import Modal from './Modal/index.js';
import DatePickerComponent from './Buttons/DatePicker.js';
import { FaSearchPlus, FaSearchMinus, FaPlus } from 'react-icons/fa';
import useNotification from '../../Components/Notification/index';
import useTimeBlocks from './Hooks/fetchTimeblocks.js';
import useFilteredBlocks from './Hooks/useFilterBlocks.js';
import ShiftSelector from './Buttons/ShiftSelector.js'; // Updated import
import { shifts } from './Utils/constants.js';
import './css/dayCalendar.css';
import './css/mobile.css';

const DayCalendar = () => {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [zoomLevel, setZoomLevel] = useState(1);
  const [editingBlock, setEditingBlock] = useState(null);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [isDatePickerOpen, setIsDatePickerOpen] = useState(false);

  // State for ShiftSelector
  const [isShiftOptionsOpen, setIsShiftOptionsOpen] = useState(false);
  const [selectedShift, setSelectedShift] = useState('');

  // State for hiddenBefore (pinned hour)
  const [hiddenBefore, setHiddenBefore] = useState(null);

  const { triggerNotification, NotificationComponent } = useNotification();
  const {
    blocks,
    addTimeBlock,
    updateTimeBlock,
    deleteTimeBlock,
    handleTimeBlockMove,
    formatDateKey,
  } = useTimeBlocks(triggerNotification);

  const blocksForSelectedDate = useFilteredBlocks(blocks, selectedDate, formatDateKey);

  // Initialize hiddenBefore from localStorage
  useEffect(() => {
    const storedHiddenBefore = localStorage.getItem('hiddenBefore');
    if (storedHiddenBefore !== null) {
      const parsedHiddenBefore = parseInt(storedHiddenBefore, 10);
      if (!isNaN(parsedHiddenBefore) && parsedHiddenBefore >= 0 && parsedHiddenBefore < 24) {
        setHiddenBefore(parsedHiddenBefore);
      }
    }
  }, []);

  const openModal = () => {
    setEditingBlock(null);
    setIsModalOpen(true);
  };

  const closeModal = () => {
    setIsModalOpen(false);
    setEditingBlock(null);
  };

  const handleZoomIn = () => {
    if (zoomLevel < 2) {
      setZoomLevel(zoomLevel * 2);
    }
  };

  const handleZoomOut = () => {
    if (zoomLevel > 0.5) {
      setZoomLevel(zoomLevel / 2);
    }
  };

  // Handle shift selection
  const handleShiftSelection = (shift) => {
    setSelectedShift(shift);
    setIsShiftOptionsOpen(false);

    if (shift && shifts[shift]) {
      const startHour = parseInt(shifts[shift].start.split(':')[0], 10);
      setHiddenBefore(startHour);
      localStorage.setItem('hiddenBefore', startHour);
    } else {
      setHiddenBefore(null);
      localStorage.removeItem('hiddenBefore');
    }
  };

  return (
    <div className="day-calendar-page">
      <NotificationComponent />
      <DatePickerComponent
        selectedDate={selectedDate}
        setSelectedDate={setSelectedDate}
        isDatePickerOpen={isDatePickerOpen}
        setIsDatePickerOpen={setIsDatePickerOpen}
      />

      {/* Shift Selector */}
      <ShiftSelector
        shifts={shifts}
        selectedShift={selectedShift}
        setSelectedShift={setSelectedShift}
        isShiftOptionsOpen={isShiftOptionsOpen}
        setIsShiftOptionsOpen={setIsShiftOptionsOpen}
        onShiftSelect={handleShiftSelection} // Pass the handler
      />

      <div className="day-calendar">
        <Timeline
          timeBlocks={blocksForSelectedDate}
          zoomLevel={zoomLevel}
          onTimeBlockClick={(block) => {
            setEditingBlock(block);
            setIsModalOpen(true);
          }}
          onTimeBlockMove={handleTimeBlockMove}
          hiddenBefore={hiddenBefore} // Pass hiddenBefore to Timeline
          setHiddenBefore={setHiddenBefore} // Pass setHiddenBefore to Timeline
        />
        {isModalOpen && (
          <Modal
            onClose={closeModal}
            onSave={editingBlock ? updateTimeBlock : addTimeBlock}
            onDelete={deleteTimeBlock}
            existingBlock={editingBlock}
            selectedDate={selectedDate}
            triggerNotification={triggerNotification}
          />
        )}
        <div className="controls">
          <button className="control-button green-button" onClick={openModal}>
            <FaPlus />
          </button>
          <button
            className="control-button round-button"
            onClick={handleZoomIn}
            disabled={zoomLevel === 2}
            style={{ display: zoomLevel === 2 ? 'none' : 'block' }}
          >
            <FaSearchPlus />
          </button>
          <button
            className="control-button"
            onClick={handleZoomOut}
            disabled={zoomLevel === 0.5}
            style={{ display: zoomLevel === 0.5 ? 'none' : 'block' }}
          >
            <FaSearchMinus />
          </button>
        </div>
      </div>
    </div>
  );
};

export default withHeader(DayCalendar);


--- time.js ---
// src/Pages/DayCalendar/Timeline.js

import React, { useEffect, useRef } from 'react';
import Draggable from 'react-draggable';
import { FaGripHorizontal, FaThumbtack, FaRedo } from 'react-icons/fa';
import useBlockPositions from './Hooks/useBlockPositions';
import useTimelineSettings from './Hooks/useTimeSettings';
import useDragHandlers from './Hooks/useDragHandlers';
import { parseTime } from './Utils/timeUtils';
import './css/timeline.css';

const Timeline = ({
  timeBlocks,
  zoomLevel,
  onTimeBlockClick,
  onTimeBlockMove,
  hiddenBefore,
  setHiddenBefore,
}) => {
  const scrollableRef = useRef(null);

  const hourHeight = 60 * zoomLevel;
  const { hourInterval, snappingIntervalMinutes, hours } = useTimelineSettings(zoomLevel);
  const [blockPositions, setBlockPositions] = useBlockPositions(timeBlocks, hourHeight);

  const pixelOffset = hiddenBefore !== null ? hiddenBefore * hourHeight : 0;
  const getPixelOffset = () => pixelOffset;

  const { dragging, handleDragStart, handleDrag, handleDragStop } = useDragHandlers(
    hourHeight,
    snappingIntervalMinutes,
    onTimeBlockMove,
    getPixelOffset
  );

  const containerHeight =
    hiddenBefore !== null ? (24 - hiddenBefore) * hourHeight : 24 * hourHeight;

  useEffect(() => {
    if (scrollableRef.current) {
      scrollableRef.current.scrollTop = 0;
    }
  }, [hiddenBefore, hourHeight]);

  const handleClick = (block, event) => {
    if (dragging) {
      event.stopPropagation();
      return;
    }
    onTimeBlockClick(block);
  };

  const handleEyeClick = (hour, event) => {
    event.stopPropagation();
    if (hiddenBefore === hour) {
      setHiddenBefore(null);
      localStorage.removeItem('hiddenBefore');
      console.log(`Showing all times again`);
    } else {
      setHiddenBefore(hour);
      localStorage.setItem('hiddenBefore', hour);
      console.log(`Hiding times before hour: ${hour}`);
    }
  };

  const filteredHours =
    hiddenBefore !== null ? hours.filter((hour) => hour >= hiddenBefore) : hours;

  const filteredTimeBlocks =
    hiddenBefore !== null
      ? timeBlocks.filter((block) => parseTime(block.startTime) >= hiddenBefore)
      : timeBlocks;

  return (
    <div className="timeline">
      <div className="timeline-scrollable" ref={scrollableRef}>
        <div className="timeline-container" style={{ height: `${containerHeight}px` }}>
          {filteredHours.map((hour, index) => (
            <div
              key={index}
              className="timeline-hour"
              style={{
                top: `${(hour - (hiddenBefore || 0)) * hourHeight}px`,
                height: `${hourHeight * hourInterval}px`,
              }}
            >
              <div className="hour-label">
                <FaThumbtack
                  className={`hour-eye ${hiddenBefore === hour ? 'active' : ''}`}
                  onClick={(e) => handleEyeClick(hour, e)}
                />
                <span className="hour-label-span">
                  {`${String(Math.floor(hour)).padStart(2, '0')}:${
                    hour % 1 === 0.5
                      ? '30'
                      : hour % 1 === 0.25
                      ? '15'
                      : hour % 1 === 0.75
                      ? '45'
                      : '00'
                  }`}
                </span>
              </div>
              <div className="hour-line"></div>
            </div>
          ))}
          {filteredTimeBlocks.map((block) => {
            const position = blockPositions[block._id] || { x: 0, y: 0 };
            const adjustedY = hiddenBefore !== null ? position.y - pixelOffset : position.y;

            const adjustedPosition = { x: position.x, y: adjustedY };

            const blockDurationMinutes = parseTime(block.endTime) - parseTime(block.startTime);
            const blockHeight = (blockDurationMinutes / 60) * hourHeight;

            const isRepeated = block.dayOfWeekBlock === true;

            return (
              <Draggable
                axis="y"
                bounds="parent"
                onStart={isRepeated ? () => false : handleDragStart}
                onDrag={
                  isRepeated
                    ? null
                    : (e, data) => handleDrag(e, data, block, setBlockPositions)
                }
                onStop={
                  isRepeated
                    ? null
                    : (e, data) => handleDragStop(e, data, block, setBlockPositions)
                }
                key={block._id + block.startTime + block.endTime}
                position={adjustedPosition}
                handle=".grip-handle"
                disabled={isRepeated} // Disable dragging for repeated blocks
              >
                <div
                  className="time-block"
                  style={{
                    height: `${blockHeight}px`,
                    backgroundColor: block.kleurInstelling,
                    transition: 'transform 0.2s ease-in-out',
                  }}
                  onClick={(event) => handleClick(block, event)}
                >
                  <div className="time-block-title">
                    {block.title}{' '}
                    <span className="time-block-time">
                      {`${block.startTime} - ${block.endTime}`}
                    </span>
                    {block.dayOfWeekBlock && (
                      <FaRedo
                        style={{
                          opacity: 0.5,
                          color: 'white',
                          marginLeft: '5px',
                          verticalAlign: 'middle',
                          fontSize: '10px',
                        }}
                      />
                    )}
                  </div>
                  <div
                    className="grip-handle"
                    style={{
                      opacity: isRepeated ? 0 : 1, // Hide grip for repeated blocks
                      cursor: isRepeated ? 'default' : 'grab',
                    }}
                  >
                    <FaGripHorizontal />
                  </div>
                </div>
              </Draggable>
            );
          })}
        </div>
      </div>
    </div>
  );
};

export default Timeline;



Directory Structure for "/Users/thibaultvandesompele/Desktop/Mateza 4.0/Client/Dashboard/dashboard-general/src/Pages/DayCalendar":

├── Buttons
│   ├── DatePicker.js
│   ├── ShiftSelector.js
│   └── css
│       ├── datePicker.css
│       └── shiftSelector.css
├── Hooks
│   ├── fetchTimeblocks.js
│   ├── useBlockPositions.js
│   ├── useDragHandlers.js
│   ├── useFilterBlocks.js
│   └── useTimeSettings.js
├── Modal
│   ├── Exceptions
│   │   ├── ExceptionItems.js
│   │   ├── Exceptions.js
│   │   └── css
│   │       └── exceptions.css
│   ├── Hooks
│   │   └── useSchemeValidation.js
│   ├── ModalContent.js
│   ├── Scheme
│   │   ├── SchemeItem.js
│   │   ├── ShiftItem.js
│   │   ├── Shifts.js
│   │   ├── ToggleSwitch.js
│   │   ├── css
│   │   │   └── scheme.css
│   │   └── index.js
│   ├── css
│   │   ├── mobile.css
│   │   └── modalContent.css
│   └── index.js
├── SchemeStandalone.js
├── Utils
│   ├── constants.js
│   ├── dateFormat.js
│   └── timeUtils.js
├── css
│   ├── dayCalendar.css
│   ├── mobile.css
│   └── timeline.css
├── index.js
└── time.js


List of Files:
Buttons/DatePicker.js
Buttons/ShiftSelector.js
Hooks/fetchTimeblocks.js
Hooks/useBlockPositions.js
Hooks/useDragHandlers.js
Hooks/useFilterBlocks.js
Hooks/useTimeSettings.js
Modal/Exceptions/ExceptionItems.js
Modal/Exceptions/Exceptions.js
Modal/Hooks/useSchemeValidation.js
Modal/ModalContent.js
Modal/Scheme/SchemeItem.js
Modal/Scheme/ShiftItem.js
Modal/Scheme/Shifts.js
Modal/Scheme/ToggleSwitch.js
Modal/Scheme/index.js
Modal/index.js
SchemeStandalone.js
Utils/constants.js
Utils/dateFormat.js
Utils/timeUtils.js
index.js
time.js

**Instruction:**
1. Please encapsulate the main component in index.js inside the `.component-name-component` class.
2. Prefix all CSS classes with the `.component-name-component` class. Sometimes the encapsulation is already done, and we don't need to do it twice. Don't write any comments. Delete all comments and don't write any extra comments. Only print the code with changes. Print the codes in full. Don't skip anything print them full. Mark all changed files with CHANGED before printing the file else mark them with --unchanged and don't print them. Only print every file once.

**Note:** CSS files have been excluded from this prompt.