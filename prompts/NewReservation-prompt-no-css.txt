File Contents:

--- Calendar.js ---
// src/components/ReservationForm/Calendar.js

import React, { useState, useEffect, useRef } from 'react';
import moment from 'moment-timezone';
import 'moment/locale/nl';
import { isWeekInPast, isSameDay } from './Utils/dateUtils';
import './css/calendar.css';

moment.locale('nl');

const Calendar = ({
  availableDates,
  selectedDate,
  onSelectDate,
  autoExpand,
}) => {
  const [isExpanded, setIsExpanded] = useState(autoExpand || false);
  const [startDate, setStartDate] = useState(null);
  const calendarRef = useRef(null);

  const maxDate = moment().tz('Europe/Amsterdam').add(1, 'year').endOf('day');

  useEffect(() => {
    if (autoExpand) {
      setIsExpanded(true);
    }
  }, [autoExpand]);

  useEffect(() => {
    const today = moment().tz('Europe/Amsterdam').startOf('day');
    let firstWeekStart = today.clone().startOf('isoWeek');
    while (isWeekInPast(firstWeekStart)) {
      firstWeekStart.add(1, 'week');
    }
    setStartDate(firstWeekStart);
  }, []);

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (
        calendarRef.current &&
        !calendarRef.current.contains(event.target)
      ) {
        setIsExpanded(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  const generateCalendarDays = (startDate) => {
    const days = [];
    const today = moment().tz('Europe/Amsterdam').startOf('day');
    const twoWeeksFromStart = startDate.clone().add(13, 'days');

    let date = startDate.clone();
    while (date.isSameOrBefore(twoWeeksFromStart, 'day')) {
      const formattedDate = date.format('YYYY-MM-DD');
      const isAvailable = availableDates.includes(formattedDate);

      days.push({
        date: date.clone(),
        isPast: date.isBefore(today, 'day'),
        isFuture: date.isAfter(maxDate, 'day'),
        isAvailable: isAvailable,
      });

      date.add(1, 'day');
    }

    return days;
  };

  const handleDateClick = (day) => {
    if (day.isAvailable && !day.isPast && !day.isFuture) {
      onSelectDate(day.date.toDate());
      setIsExpanded(false);
    } else {
      console.log('Date is not available for selection.');
    }
  };

  const handlePrevWeek = () => {
    const newStartDate = startDate.clone().subtract(1, 'week');
    if (isWeekInPast(newStartDate)) {
      console.log('Cannot go to previous week. It is in the past.');
      return;
    }
    setStartDate(newStartDate);
  };

  const handleNextWeek = () => {
    const newStartDate = startDate.clone().add(1, 'week');
    setStartDate(newStartDate);
  };

  const formatDisplayDate = () => {
    if (!selectedDate) {
      return 'Selecteer een datum';
    }

    const selectedMoment = moment(selectedDate)
      .tz('Europe/Amsterdam')
      .startOf('day');
    const today = moment().tz('Europe/Amsterdam').startOf('day');
    const tomorrow = moment()
      .tz('Europe/Amsterdam')
      .add(1, 'day')
      .startOf('day');

    if (selectedMoment.isSame(today, 'day')) {
      return 'Vandaag';
    } else if (selectedMoment.isSame(tomorrow, 'day')) {
      return 'Morgen';
    } else {
      return selectedMoment.format('DD MMMM YYYY');
    }
  };

  const days = startDate ? generateCalendarDays(startDate) : [];

  return (
    <div className="calendar-container" ref={calendarRef}>
      <div
        className="calendar-display"
        onClick={() => {
          setIsExpanded(!isExpanded);
        }}
      >
        <span>{formatDisplayDate()}</span>
        <span className="arrow">
          <svg
            width="12"
            height="12"
            viewBox="0 0 24 24"
            style={{
              transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
              transition: 'transform 0.2s',
            }}
          >
            <path
              d="M7 10l5 5 5-5"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
            />
          </svg>
        </span>
      </div>
      {isExpanded && startDate && (
        <div className="calendar">
          <div className="calendar-header">
            <button type="button" onClick={handlePrevWeek}>
              &lt;
            </button>
            <span>
              {startDate.format('DD MMM')} -{' '}
              {startDate.clone().add(13, 'days').format('DD MMM YYYY')}
            </span>
            <button type="button" onClick={handleNextWeek}>
              &gt;
            </button>
          </div>
          <div className="calendar-weeks-wrapper">
            <table className="calendar-table">
              <thead>
                <tr>
                  {['Ma', 'Di', 'Wo', 'Do', 'Vr', 'Za', 'Zo'].map((day) => (
                    <th key={day}>{day}</th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {Array.from({ length: 2 }).map((_, weekIndex) => (
                  <tr key={weekIndex}>
                    {days
                      .slice(weekIndex * 7, weekIndex * 7 + 7)
                      .map((dayObj, index) => {
                        const isSelected =
                          selectedDate &&
                          isSameDay(
                            dayObj.date,
                            moment(selectedDate).tz('Europe/Amsterdam')
                          );
                        const classNames = [];
                        if (dayObj.isPast) {
                          classNames.push('gray-out');
                        } else if (dayObj.isAvailable) {
                          classNames.push('available');
                        } else {
                          classNames.push('unavailable');
                        }
                        if (isSelected) {
                          classNames.push('selected');
                        }

                        return (
                          <td
                            key={index}
                            className={classNames.join(' ')}
                            onClick={() => handleDateClick(dayObj)}
                            style={{
                              '--animation-order': index + weekIndex * 7,
                            }}
                          >
                            <div className="day-square">
                              {dayObj.date.date()}
                            </div>
                          </td>
                        );
                      })}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}
    </div>
  );
};

export default Calendar;


--- DateSelector.js ---
// src/components/ReservationForm/DateSelector.jsx

import React, { useEffect, useState } from 'react';
import Calendar from './Calendar';
import { generateAvailableDates } from './Utils/generateDates';

const DateSelector = ({
  formData,
  handleChange,
  resetFormDataFields,
  timeblocks,
  expanded,
  setCurrentExpandedField,
}) => {
  const [availableDates, setAvailableDates] = useState([]);

  console.log("timeblocks");
  console.log(timeblocks);

  useEffect(() => {
    if (timeblocks && Array.isArray(timeblocks)) {
      const dates = generateAvailableDates(timeblocks);
      setAvailableDates(dates);
    } else {
      console.error("timeblocks is undefined or not an array:", timeblocks);
      setAvailableDates([]);
    }
  }, [timeblocks]);

  const handleDateSelect = (date) => {
    handleChange({
      target: { name: 'date', value: date },
    });
    resetFormDataFields(['time']);
    if (setCurrentExpandedField) {
      setCurrentExpandedField('time');
    }
  };

  return (
    <div className="form-group date-selector-container">
      <label htmlFor="date" className="default-text-color">
        Datum<span className="required">*</span>
      </label>
      <Calendar
        availableDates={availableDates}
        selectedDate={formData.date ? formData.date : null}
        onSelectDate={handleDateSelect}
        autoExpand={expanded}
      />
    </div>
  );
};

export default DateSelector;


--- FormField.js ---
// src/components/Profile/FormField.jsx

import React from 'react';

const FormField = ({ label, name, type = 'text', icon: Icon, value, onChange, error, placeholder, halfWidth }) => (
  <div className={`form-group ${halfWidth ? 'half-width' : ''}`}>
    <div className="input-container">
      {Icon && <Icon className="input-icon" />}
      <input
        type={type}
        name={name}
        placeholder={placeholder}
        value={value}
        onChange={onChange}
        aria-label={label}
      />
    </div>
    {error && <p className="form-error">{error}</p>}
  </div>
);

export default FormField;


--- Hooks/useFetchRestaurantData.js ---
// src/Hooks/useFetchRestaurantData.js

import { useState, useEffect } from 'react';
import useApi from '../../../Hooks/useApi';

const useFetchRestaurantData = () => {
  const [restaurantData, setRestaurantData] = useState(null);
  const api = useApi();


  useEffect(() => {
    const fetchRestaurantData = async () => {
      try {
        const endpoint = `${window.baseDomain}api/auth-restaurant/`;
        const response = await api.get(endpoint);


        if (response) {
          setRestaurantData(response);
        }
      } catch (error) {
        console.error('Error fetching restaurant data:', error);
        const errorCode = error.response?.status || 'unknown';
      }
    };

    fetchRestaurantData();
  }, [api]);

  return restaurantData;
};

export default useFetchRestaurantData;


--- ReservationStepOne.js ---
// src/components/ReservationForm/ReservationStepOne.jsx

import React from 'react';
import ValueSelectorGuests from './ValueSelector'; // Import the guests value selector
import DateSelector from './DateSelector';
import TimeSelector from './TimeSelector';
import './css/newReservationAdmin.css'; // Ensure CSS is imported

const ReservationStepOne = ({
  formData,
  errors,
  handleChange,
  handleStepOneSubmit,
  setFormData,
  timeblocks,
}) => {
  const resetFormDataFields = (fieldsToReset) => {
    const newFormData = { ...formData };
    fieldsToReset.forEach((field) => {
      newFormData[field] = '';
    });
    setFormData(newFormData);
  };

  console.log("timeblocks");
  console.log(timeblocks);

  return (
    <form className="account-manage-form" onSubmit={handleStepOneSubmit} noValidate>
      <ValueSelectorGuests
        value={formData.numberOfGuests}
        onChange={handleChange}
        error={errors.numberOfGuests}
      />

      <DateSelector
        formData={formData}
        handleChange={handleChange}
        resetFormDataFields={resetFormDataFields}
        timeblocks={timeblocks} // Pass timeblocks here
        expanded={false}
        setCurrentExpandedField={() => {}}
      />

      <TimeSelector
        formData={formData}
        handleChange={handleChange}
        field={{ id: 'time', label: 'Tijd' }}
        selectedDate={formData.date}
        expanded={false}
        setCurrentExpandedField={() => {}}
      />

      <button type="submit" className="account-manage__button">
        Verder
      </button>
    </form>
  );
};

export default ReservationStepOne;


--- ReservationStepTwoModal.js ---
// src/components/ReservationForm/ReservationStepTwoModal.jsx

import React from 'react';
import FormField from './FormField';
import { FaUser, FaPhone, FaInfoCircle, FaEnvelope } from 'react-icons/fa';

const ReservationStepTwoModal = ({
  formData,
  errors,
  handleChange,
  handleFinalSubmit,
  isSubmitting,
}) => {
  return (
    <div>
      <h2 className="modal-title">Persoonlijke Informatie</h2>
      <form className="account-manage-form" onSubmit={handleFinalSubmit} noValidate>
        <FormField
          label="Voornaam"
          name="firstName"
          placeholder="Voornaam"
          value={formData.firstName}
          onChange={handleChange}
          error={errors.firstName}
          icon={FaUser}
        />
        <FormField
          label="Achternaam"
          name="lastName"
          placeholder="Achternaam"
          value={formData.lastName}
          onChange={handleChange}
          error={errors.lastName}
          icon={FaUser}
        />
        <FormField
          label="E-mail"
          name="email"
          type="email"
          placeholder="E-mailadres"
          value={formData.email}
          onChange={handleChange}
          error={errors.email}
          icon={FaEnvelope}
        />
        <FormField
          label="Telefoonnummer"
          name="phone"
          type="tel"
          placeholder="Telefoonnummer"
          value={formData.phone}
          onChange={handleChange}
          error={errors.phone}
          icon={FaPhone}
        />
        <FormField
          label="Extra info"
          name="extraInfo"
          type="textarea"
          placeholder="Extra informatie"
          value={formData.extraInfo}
          onChange={handleChange}
          error={errors.extraInfo}
          icon={FaInfoCircle}
        />
        <button type="submit" className="account-manage__button" disabled={isSubmitting}>
          {isSubmitting ? 'Verzenden...' : 'Reserveren'}
        </button>
      </form>
    </div>
  );
};

export default ReservationStepTwoModal;


--- TimeSelector.js ---
// src/components/ReservationForm/TimeSelector.jsx

import React, { useState, useEffect, useRef } from 'react';
import { generateAvailableTimesForDate } from './Utils/generateAvailableTimesForDate';
import './css/timeSelector.css'

const TimeSelector = ({
  formData,
  handleChange,
  field,
  selectedDate,
  expanded,
  setCurrentExpandedField,
}) => {
  const [isExpanded, setIsExpanded] = useState(expanded || false);
  const [availableTimes, setAvailableTimes] = useState([]);
  const timeSelectorRef = useRef(null);

  useEffect(() => {
    if (selectedDate) {
      const times = generateAvailableTimesForDate(selectedDate);
      setAvailableTimes(times);
    } else {
      setAvailableTimes([]);
    }
  }, [selectedDate]);

  const handleTimeSelect = (timeValue) => {
    handleChange({
      target: { name: field.id, value: timeValue },
    });
    setIsExpanded(false);
    if (setCurrentExpandedField) {
      setCurrentExpandedField(null);
    }
  };

  const formatDisplayTime = () => {
    if (formData[field.id]) {
      const selected = availableTimes.find((time) => time.value === formData[field.id]);
      return selected ? selected.label : 'Selecteer een tijd';
    }
    return 'Selecteer een tijd';
  };

  if (!field) {
    return null;
  }

  return (
    <div className="form-group time-selector-container" ref={timeSelectorRef}>
      <label className="default-text-color" htmlFor={field.id}>
        {field.label}
        <span className="required">*</span>
      </label>

      {!selectedDate ? (
        <p className="info-text">Selecteer eerst een datum.</p>
      ) : (
        <>
          <div
            className="time-display"
            onClick={() => {
              setIsExpanded(!isExpanded);
              if (!isExpanded && setCurrentExpandedField) {
                setCurrentExpandedField('time');
              }
            }}
          >
            <span>{formatDisplayTime()}</span>
            <span className="arrow">
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                style={{
                  transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
                  transition: 'transform 0.2s',
                }}
              >
                <path
                  d="M7 10l5 5 5-5"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                />
              </svg>
            </span>
          </div>
          {isExpanded && (
            <div className="time-selector">
              {availableTimes.length === 0 ? (
                <div className="no-times">Geen beschikbare tijden.</div>
              ) : (
                <div className="time-options">
                  {availableTimes.map((time) => (
                    <div
                      key={time.value}
                      className={`time-option ${
                        formData[field.id] === time.value ? 'selected' : ''
                      }`}
                      onClick={() => handleTimeSelect(time.value)}
                    >
                      {time.label}
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}
        </>
      )}
    </div>
  );
};

export default TimeSelector;


--- Utils/dateUtils.js ---
// src/components/ReservationForm/Utils/dateUtils.js

import moment from 'moment-timezone';

export const isWeekInPast = (weekStartDate) => {
  const today = moment().tz('Europe/Brussels').startOf('day');
  const weekEndDate = weekStartDate.clone().add(6, 'days').endOf('day');
  return weekEndDate.isBefore(today);
};

export const isSameDay = (date1, date2) => date1.isSame(date2, 'day');


--- Utils/generateAvailableTimesForDate.js ---
// src/components/ReservationForm/Utils/generateAvailableTimesForDate.js

import moment from 'moment-timezone';

export const generateAvailableTimesForDate = (selectedDate) => {
  if (!selectedDate) {
    return [];
  }

  const selectedDateStr = moment(selectedDate).format('YYYY-MM-DD');
  const timeEntries = window.dateDictionary[selectedDateStr];

  if (!timeEntries || timeEntries.length === 0) {
    return [];
  }

  const times = [];
  const intervalMinutes = 30; // Adjust as needed

  timeEntries.forEach((entry) => {
    const startTime = moment(entry.startTime, 'HH:mm');
    const endTime = moment(entry.endTime, 'HH:mm');

    let currentTime = startTime.clone();
    while (currentTime.isBefore(endTime)) {
      times.push({
        label: currentTime.format('HH:mm'),
        value: currentTime.format('HH:mm'),
      });
      currentTime.add(intervalMinutes, 'minutes');
    }
  });

  return times;
};


--- Utils/generateDates.js ---
// Calendar/generateDates.js

import { DateTime } from 'luxon';

const getOrInitializeArray = (dict, key) => {
    if (!Array.isArray(dict[key])) {
        dict[key] = [];
    }
    return dict[key];
};

const initializeDictionaries = () => {
    window.dateDictionary = window.dateDictionary || {};
    window.shiftsPerDate = window.shiftsPerDate || {};
};

const processTimeblock = (block) => {
    if (!block.date) {
        return;
    }

    const dateString = DateTime.fromISO(block.date, { zone: "Europe/Brussels" }).toISODate();

    if (!window.dateDictionary[dateString]) {
        window.dateDictionary[dateString] = [];
    }
    window.dateDictionary[dateString].push({
        startTime: block.startTime || null,
        endTime: block.endTime || null
    });

    if (block.shifts && Array.isArray(block.shifts) && block.shifts.length > 0) {
        const shiftsArray = getOrInitializeArray(window.shiftsPerDate, dateString);

        block.shifts.forEach(shift => {
            const exists = shiftsArray.some(existingShift => 
                existingShift.name === shift.name && existingShift.startTime === shift.startTime
            );
            if (!exists) {
                shiftsArray.push({
                    name: shift.name || '',
                    startTime: shift.startTime || '',
                    endTime: shift.endTime || null
                });
            }
        });
    }
};

const getBlockSettingsDates = (timeblocks) => {
    initializeDictionaries();
    const dates = [];

    timeblocks.forEach((block) => {
        processTimeblock(block);
        if (block.date) {
            const dateString = DateTime.fromISO(block.date, { zone: "Europe/Brussels" }).toISODate();
            dates.push(dateString);
        }
    });

    return dates;
};

const isWithinPeriod = (currentDate, endDate) => {
    return currentDate <= endDate;
};

const processDaySetting = (dateString, daySetting) => {
    if (!window.dateDictionary[dateString]) {
        window.dateDictionary[dateString] = [];
    }
    window.dateDictionary[dateString].push({
        startTime: daySetting.startTime || null,
        endTime: daySetting.endTime || null,
    });

    if (daySetting.shiftsEnabled && Array.isArray(daySetting.shifts) && daySetting.shifts.length > 0) {
        console.log(`[processDaySetting] Processing shifts for ${dateString}`);
        const shiftsArray = getOrInitializeArray(window.shiftsPerDate, dateString);

        daySetting.shifts.forEach(shift => {
            const exists = shiftsArray.some(existingShift => 
                existingShift.name === shift.name && existingShift.startTime === shift.startTime
            );
            if (!exists) {
                shiftsArray.push({
                    name: shift.name || '',
                    startTime: shift.startTime || '',
                    endTime: shift.endTime || null
                });
            }
        });
    }
};

const getSchemeSettingsDates = (timeblocks) => {
    console.log(`[getSchemeSettingsDates] Starting processing of scheme settings dates.`);
    initializeDictionaries();
    const dates = [];
    const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

    timeblocks.forEach((block) => {
        if (!block.schemeSettings) {
            return;
        }

        const { schemeSettings } = block;
        let currentDate = DateTime.now().setZone("Europe/Brussels").startOf('day');
        let endDate = currentDate.plus({ days: 365 }).startOf('day');

        if (schemeSettings.period && schemeSettings.period.enabled) {
            const { startDate, endDate: periodEndDate } = schemeSettings.period;
            if (startDate && periodEndDate) {
                currentDate = DateTime.fromISO(startDate, { zone: "Europe/Brussels" }).startOf('day');
                endDate = DateTime.fromISO(periodEndDate, { zone: "Europe/Brussels" }).endOf('day');
            }
        }

        while (isWithinPeriod(currentDate, endDate)) {
            const dayOfWeek = currentDate.weekday % 7;
            const dayName = dayNames[dayOfWeek];
            const daySetting = schemeSettings[dayName];
            if (daySetting && daySetting.enabled) {
                const dateString = currentDate.toISODate();
                dates.push(dateString);
                processDaySetting(dateString, daySetting);
            }

            currentDate = currentDate.plus({ days: 1 });
        }
    });
    return dates;
};

export const generateAvailableDates = (timeblocks) => {
    initializeDictionaries();

    const blockDates = getBlockSettingsDates(timeblocks);
    const schemeDates = getSchemeSettingsDates(timeblocks);
    const combinedDates = [...blockDates, ...schemeDates];
    const uniqueDates = Array.from(new Set(combinedDates)).sort();
    return uniqueDates;
};


--- ValueSelector.js ---
// ValueSelectorGuests.jsx

import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion'; // Import Framer Motion
import './css/valueSelector.css'; // Use the same CSS as ValueSelector

const ValueSelectorGuests = ({ value, onChange }) => {
  const predefinedValues = [1, 2, 3, '4+ Gasten'];
  const [selectedValue, setSelectedValue] = useState(value || '');
  const [showSlider, setShowSlider] = useState(false);

  const handlePredefinedValueClick = (val) => {
    if (val === '4+ Gasten') {
      setShowSlider(true);
      setSelectedValue(4);
      onChange({ target: { name: 'numberOfGuests', value: 4 } });
    } else {
      setShowSlider(false);
      setSelectedValue(val);
      onChange({ target: { name: 'numberOfGuests', value: val } });
    }
  };

  const handleSliderChange = (e) => {
    const val = e.target.value;
    setSelectedValue(val);
    onChange({ target: { name: 'numberOfGuests', value: val } });
  };

  const handleInputChange = (e) => {
    const val = e.target.value;
    setSelectedValue(val);
    onChange({ target: { name: 'numberOfGuests', value: val } });
  };

  return (
    <div className="value-selector">
      <div className="predefined-values">
        {predefinedValues.map((val) => (
          <button
            key={val}
            type="button"
            className={`predefined-value-button ${
              selectedValue == val || (val === '4+ Gasten' && showSlider) ? 'active' : ''
            }`}
            onClick={() => handlePredefinedValueClick(val)}
          >
            {val === '4+ Gasten' ? '4+ Gasten' : `${val} ${val === 1 ? 'Gast' : 'Gasten'}`}
          </button>
        ))}
      </div>
      <AnimatePresence>
        {showSlider && (
          <motion.div
            className="slider-container"
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
          >
            <input
              type="range"
              min="4"
              max="15"
              step="1"
              value={selectedValue}
              onChange={handleSliderChange}
              className="slider"
            />
            <input
              type="number"
              name="numberOfGuests"
              value={selectedValue}
              onChange={handleInputChange}
              className="value-input"
              min="4"
              max="100"
              step="1"
            />
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default ValueSelectorGuests;


--- index.js ---
// src/components/ReservationForm/NewReservationAdmin.jsx

import React, { useState, useEffect } from 'react';
import './css/newReservationAdmin.css';
import ModalWithoutTabs from '../../Components/Structural/Modal/Standard';
import useApi from '../../Hooks/useApi';
import ReservationStepOne from './ReservationStepOne';
import ReservationStepTwoModal from './ReservationStepTwoModal';
import { withHeader } from '../../Components/Structural/Header';

const NewReservationAdmin = () => {
  const api = useApi();

  // State for restaurant data
  const [restaurantData, setRestaurantData] = useState(null);
  const [loadingRestaurantData, setLoadingRestaurantData] = useState(true);
  const [restaurantDataError, setRestaurantDataError] = useState(null);

  // Form state
  const [formData, setFormData] = useState({
    numberOfGuests: '',
    date: '',
    time: '',
    firstName: '',
    lastName: '',
    email: '',
    phone: '',
    extraInfo: '',
  });

  // Error state
  const [errors, setErrors] = useState({});

  // Modal and submission states
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Extract timeblocks from restaurantData
  const timeblocks = restaurantData?.timeblocks || [];

  console.log("timeblocks", timeblocks);

  // Fetch restaurant data on component mount
  useEffect(() => {
    const fetchRestaurantData = async () => {
      try {
        const data = await api.get(`${window.baseDomain}api/auth-restaurant/`);
        setRestaurantData(data);
      } catch (err) {
        setRestaurantDataError(err);
        console.error('Error fetching restaurant data:', err);
      } finally {
        setLoadingRestaurantData(false);
      }
    };

    fetchRestaurantData();
  }, [api]);

  // Validation functions
  const validateStepOne = () => {
    const errors = {};
    if (!formData.numberOfGuests) {
      errors.numberOfGuests = 'Aantal gasten is verplicht';
    }
    if (!formData.date) {
      errors.date = 'Datum is verplicht';
    }
    if (!formData.time) {
      errors.time = 'Tijd is verplicht';
    }
    return errors;
  };

  const validateStepTwo = () => {
    const errors = {};
    if (!formData.firstName) {
      errors.firstName = 'Voornaam is verplicht';
    }
    if (!formData.lastName) {
      errors.lastName = 'Achternaam is verplicht';
    }
    if (!formData.email) {
      errors.email = 'E-mail is verplicht';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      errors.email = 'E-mail is ongeldig';
    }
    if (!formData.phone) {
      errors.phone = 'Telefoonnummer is verplicht';
    }
    return errors;
  };

  // Handle submission of Step One
  const handleStepOneSubmit = (e) => {
    e.preventDefault();
    const stepOneErrors = validateStepOne();
    if (Object.keys(stepOneErrors).length > 0) {
      setErrors(stepOneErrors);
    } else {
      setErrors({});
      setIsModalOpen(true);
    }
  };

  // Handle final submission of the reservation
  const handleFinalSubmit = async (e) => {
    e.preventDefault();
    const stepTwoErrors = validateStepTwo();
    if (Object.keys(stepTwoErrors).length > 0) {
      setErrors(stepTwoErrors);
    } else {
      setErrors({});
      setIsSubmitting(true);
      const submissionData = {
        numberOfGuests: formData.numberOfGuests,
        date: formData.date,
        time: formData.time,
        firstName: formData.firstName,
        lastName: formData.lastName,
        email: formData.email,
        phone: formData.phone,
        extraInfo: formData.extraInfo,
      };

      try {
        await api.post(`${window.baseDomain}api/auth-reservations/`, submissionData);
        alert('Reservatie succesvol ingediend!');
        setIsModalOpen(false);
        setFormData({
          numberOfGuests: '',
          date: '',
          time: '',
          firstName: '',
          lastName: '',
          email: '',
          phone: '',
          extraInfo: '',
        });
      } catch (error) {
        if (error.response && error.response.data && error.response.data.message) {
          alert('Er is een fout opgetreden: ' + error.response.data.message);
        } else {
          alert('Er is een fout opgetreden bij het indienen van de reservatie.');
        }
        console.error('Error submitting reservation:', error);
      } finally {
        setIsSubmitting(false);
      }
    }
  };

  // Handle form field changes
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({ ...formData, [name]: value });
    setErrors({ ...errors, [name]: '' });
  };

  // Render loading state
  if (loadingRestaurantData) {
    return <div>Loading restaurant data...</div>;
  }

  // Render error state
  if (restaurantDataError) {
    return <div>Error loading restaurant data: {restaurantDataError.message}</div>;
  }

  return (
    <div className="new-reservation-admin-component">
      <div className="profile-page">
        <h2 className="account-manage-title">Admin Reservaties</h2>
        <div className="account-manage-container">
          <ReservationStepOne
            formData={formData}
            errors={errors}
            handleChange={handleChange}
            handleStepOneSubmit={handleStepOneSubmit}
            setFormData={setFormData}
            timeblocks={timeblocks} // Pass timeblocks from restaurantData
          />
        </div>

        {isModalOpen && (
          <ModalWithoutTabs
            content={
              <ReservationStepTwoModal
                formData={formData}
                errors={errors}
                handleChange={handleChange}
                handleFinalSubmit={handleFinalSubmit}
                isSubmitting={isSubmitting}
              />
            }
            onClose={() => setIsModalOpen(false)}
          />
        )}
      </div>
    </div>
  );
};

export default withHeader(NewReservationAdmin);



Directory Structure for "/Users/thibaultvandesompele/Desktop/Mateza 4.0/Client/Dashboard/dashboard-general/src/Pages/NewReservation":

├── Calendar.js
├── DateSelector.js
├── FormField.js
├── Hooks
│   └── useFetchRestaurantData.js
├── ReservationStepOne.js
├── ReservationStepTwoModal.js
├── TimeSelector.js
├── Utils
│   ├── dateUtils.js
│   ├── generateAvailableTimesForDate.js
│   └── generateDates.js
├── ValueSelector.js
├── css
│   ├── calendar.css
│   ├── newReservationAdmin.css
│   ├── timeSelector.css
│   └── valueSelector.css
└── index.js


List of Files:
Calendar.js
DateSelector.js
FormField.js
Hooks/useFetchRestaurantData.js
ReservationStepOne.js
ReservationStepTwoModal.js
TimeSelector.js
Utils/dateUtils.js
Utils/generateAvailableTimesForDate.js
Utils/generateDates.js
ValueSelector.js
index.js

**Instruction:**
1. Please encapsulate the main component in index.js inside the `.component-name-component` class.
2. Prefix all CSS classes with the `.component-name-component` class. Sometimes the encapsulation is already done, and we don't need to do it twice. Don't write any comments. Delete all comments and don't write any extra comments. Only print the code with changes. Print the codes in full. Don't skip anything print them full. Mark all changed files with CHANGED before printing the file else mark them with --unchanged and don't print them. Only print every file once.

**Note:** CSS files have been excluded from this prompt.