File Contents:

--- FormField.js ---
// src/components/Profile/FormField.jsx

import React from 'react';

const FormField = ({
  label,
  name,
  type = 'text',
  icon: Icon,
  value,
  onChange,
  error,
  placeholder,
  halfWidth,
  options = [], // New prop for select options
}) => {
  return (
    <div className={`form-group ${halfWidth ? 'half-width' : ''}`}>
      <div className="input-container">
        {Icon && <Icon className="input-icon" />}
        
        {type === 'select' ? (
          <select
            name={name}
            value={value}
            onChange={onChange}
            aria-label={label}
            className={`form-control ${error ? 'input-error' : ''}`}
          >
            <option value="">Selecteer een menu</option>
            {options.map((option) => (
              <option key={option.value} value={option.value}>
                {option.label}
              </option>
            ))}
          </select>
        ) : type === 'textarea' ? (
          <textarea
            name={name}
            value={value}
            onChange={onChange}
            placeholder={placeholder}
            aria-label={label}
            className={`form-control ${error ? 'input-error' : ''}`}
          />
        ) : (
          <input
            type={type}
            name={name}
            placeholder={placeholder}
            value={value}
            onChange={onChange}
            aria-label={label}
            className={`form-control ${error ? 'input-error' : ''}`}
          />
        )}
      </div>
      {error && <p className="form-error">{error}</p>}
    </div>
  );
};

export default FormField;


--- ReservationSidebar.js ---
import React, { useEffect, useState } from 'react';
import ReservationStepOne from './StepOne';
import ReservationStepTwoFiltering from './ReservationStepTwo';
import ReservationSummary from './ReservationSummary';
import { FaTimes } from 'react-icons/fa';
import './css/reservationSidebar.css';
import useApi from '../../Hooks/useApi';

const ReservationSidebar = ({
  isOpen,
  onClose,
  formData,
  errors,
  handleChange,
  handleFinalSubmit,
  setFormData,
  isSubmitting,
  reservationSubmitted,
  onNewReservation,
}) => {
  const api = useApi();
  const [timeblocks, setTimeblocks] = useState([]);
  const [loadingTimeblocks, setLoadingTimeblocks] = useState(false);
  const [timeblocksError, setTimeblocksError] = useState(null);
  const [menuData, setMenuData] = useState([]); // Add this line

  useEffect(() => {
    if (isOpen) {
      setLoadingTimeblocks(true);
      const fetchTimeblocks = async () => {
        try {
          console.log("New Reservation GET");
          const data = await api.get(`${window.baseDomain}api/auth-restaurant/`, { noCache: true });
          setTimeblocks(data.timeblocks || []);
          window.timeblocks = data.timeblocks || []; // Retain globally if needed
          const generalSettings = data['general-settings'] || {};
          window.generalSettings = generalSettings; // Retain globally
		  setMenuData(data.menu || []); // Fetch and set menu data
        } catch (err) {
          setTimeblocksError(err);
          console.error('Error fetching timeblocks:', err);
        } finally {
          setLoadingTimeblocks(false);
        }
      };
      fetchTimeblocks();
    }
  }, [isOpen, api]);

  return (
    <div className={`reservation-sidebar-component ${isOpen ? 'open' : ''}`}>
      <div className="reservation-sidebar-content">
        <h2 className='admin-title'>Admin Reservatie</h2>

        <button className="close-sidebar-button" onClick={onClose}>
          <FaTimes size={20} color="#000" />
        </button>
        {reservationSubmitted ? (
          <ReservationSummary
            formData={formData}
            onNewReservation={() => {
              setFormData({
                guests: '',
                date: '',
                time: '',
                firstName: '',
                lastName: '',
                email: '',
                phone: '',
                extraInfo: '',
                notes: '',
              });
              onNewReservation();
            }}
          />
        ) : (
          <>
            <div className="sidebar-section-one">
              <ReservationStepOne
                formData={formData}
                errors={errors}
                handleChange={handleChange}
                setFormData={setFormData}
                timeblocks={timeblocks}
                loadingTimeblocks={loadingTimeblocks}
                timeblocksError={timeblocksError}
              />
            </div>
            <div className="sidebar-section-two">
              <ReservationStepTwoFiltering
                formData={formData}
                errors={errors}
                handleChange={handleChange}
                isSubmitting={isSubmitting}
				menuData={menuData} // Pass menuData to ReservationStepTwo

              />
            </div>
            <div className="reservation-footer">
              <button
                type="button"
                className="store-reservation-button"
                onClick={handleFinalSubmit}
                disabled={isSubmitting}
              >
                {isSubmitting ? 'Opslaan...' : 'Opslaan'}
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  );
};

export default ReservationSidebar;


--- ReservationStepTwo.js ---
import React, { useState, useEffect } from 'react';
import FormField from './FormField';
import { FaUser, FaPhone, FaInfoCircle, FaEnvelope } from 'react-icons/fa';
import moment from 'moment';
import 'moment/locale/nl'; // Import Dutch locale
import './css/reservationsStepTwo.css';

const ReservationStepTwoFiltering = ({
  formData,
  errors,
  handleChange,
  isSubmitting,
  menuData,
}) => {
  const [availableMenus, setAvailableMenus] = useState([]);

  useEffect(() => {
    moment.locale('nl'); // Set locale to Dutch
    if (formData.date && formData.time && menuData.length > 0) {
      const selectedDate = formData.date; // 'YYYY-MM-DD' format
      const selectedTime = formData.time; // 'HH:mm' format
      const selectedDateTime = moment(`${selectedDate} ${selectedTime}`, 'YYYY-MM-DD HH:mm');

      const filteredMenus = menuData.filter((menu) => {
        const menuStartDate = moment(menu.startDate, 'YYYY-MM-DD');
        const menuEndDate = moment(menu.endDate, 'YYYY-MM-DD');
        const isDateInRange = selectedDateTime.isBetween(menuStartDate, menuEndDate, 'day', '[]');

        const menuStartTime = moment(menu.startHour, 'HH:mm');
        const menuEndTime = moment(menu.endHour, 'HH:mm');
        const selectedTimeMoment = moment(selectedTime, 'HH:mm');
        const isTimeInRange = selectedTimeMoment.isBetween(menuStartTime, menuEndTime, 'minute', '[]');

        const selectedDayOfWeek = selectedDateTime.format('dddd').toLowerCase();
        const daysOfWeek = menu.daysOfWeek.map((day) => day.toLowerCase());
        const isDayMatching = daysOfWeek.length === 0 || daysOfWeek.includes(selectedDayOfWeek);

        return isDateInRange && isTimeInRange && isDayMatching;
      });

      setAvailableMenus(filteredMenus);
    } else {
      setAvailableMenus([]);
    }
  }, [formData.date, formData.time, menuData]);

  return (
    <div className="reservation-step-two">
      <div className="account-manage-form" noValidate>
        {/* Name Fields Container */}


        {/* Menu Selection Box */}
        {availableMenus.length > 0 && (
          <FormField
            label="Menu"
            name="menu"
            type="select"
            options={availableMenus.map((menu) => ({
              value: menu._id.$oid || menu._id, // Adjust according to your data structure
              label: menu.name,
            }))}
            value={formData.menu}
            onChange={handleChange}
            error={errors.menu}
          />
        )}
        
        <div className="name-fields">
          <FormField
            label="Voornaam"
            name="firstName"
            placeholder="Voornaam"
            value={formData.firstName}
            onChange={handleChange}
            error={errors.firstName}
            icon={FaUser}
          />
          <FormField
            label="Achternaam"
            name="lastName"
            placeholder="Achternaam"
            value={formData.lastName}
            onChange={handleChange}
            error={errors.lastName}
            icon={FaUser}
          />
        </div>

        {/* Other Form Fields */}
        <FormField
          label="E-mail"
          name="email"
          type="email"
          placeholder="E-mailadres"
          value={formData.email}
          onChange={handleChange}
          error={errors.email}
          icon={FaEnvelope}
        />
        <FormField
          label="Telefoonnummer"
          name="phone"
          type="tel"
          placeholder="Telefoonnummer"
          value={formData.phone}
          onChange={handleChange}
          error={errors.phone}
          icon={FaPhone}
        />
        <FormField
          label="Extra info"
          name="extraInfo"
          type="textarea"
          placeholder="Extra informatie"
          value={formData.extraInfo}
          onChange={handleChange}
          error={errors.extraInfo}
          icon={FaInfoCircle}
        />
      </div>
    </div>
  );
};

export default ReservationStepTwoFiltering;


--- ReservationSummary.js ---
// src/components/ReservationForm/ReservationSummary.jsx

import React from 'react';
import './css/reservationSummary.css'; // Import the CSS file

const ReservationSummary = ({ formData, onNewReservation }) => {
  return (
    <div className="reservation-summary">
      <ul className="reservation-details">
      <li><strong>Reservatie Gegevens:</strong></li> 
        <li><strong>Aantal gasten:</strong> {formData.guests}</li> {/* Uses guests */}
        <li><strong>Datum:</strong> {formData.date}</li>
        <li><strong>Tijd:</strong> {formData.time}</li>
        <li><strong>Voornaam:</strong> {formData.firstName}</li>
        <li><strong>Achternaam:</strong> {formData.lastName}</li>
        <li><strong>Email:</strong> {formData.email}</li>
        <li><strong>Telefoonnummer:</strong> {formData.phone}</li>
        {formData.extraInfo && (
          <li><strong>Extra informatie:</strong> {formData.extraInfo}</li>
        )}
      </ul>
      <button className="button-style-3" onClick={onNewReservation}>
        Nieuwe Reservatie Maken
      </button>
    </div>
  );
};

export default ReservationSummary;


--- StepOne/Calendar.js ---
// src/Pages/NewReservation/Calendar.jsx

import React, { useState, useEffect, useRef } from 'react';
import moment from 'moment-timezone';
import 'moment/locale/nl';
import { isWeekInPast, isSameDay } from './Utils/dateUtils';
import './css/calendar.css';
import useApi from '../../../Hooks/useApi';

moment.locale('nl'); // Set moment to Dutch locale

const Calendar = ({
  availableDates,
  selectedDate,
  onSelectDate,
  autoExpand,
  onReservationsFetched, // New prop for callback
}) => {
  const [isExpanded, setIsExpanded] = useState(autoExpand || false);
  const [startDate, setStartDate] = useState(null);
  const [reservations, setReservations] = useState(null); // Local state for reservations
  const calendarRef = useRef(null);
  const api = useApi(); // Initialize useApi hook

  const maxDate = moment().tz('Europe/Amsterdam').add(1, 'year').endOf('day');

  useEffect(() => {
    if (autoExpand) {
      setIsExpanded(true);
    }
  }, [autoExpand]);

  useEffect(() => {
    const today = moment().tz('Europe/Amsterdam').startOf('day');
    let firstWeekStart = today.clone().startOf('isoWeek');
    while (isWeekInPast(firstWeekStart)) {
      firstWeekStart.add(1, 'week');
    }
    setStartDate(firstWeekStart);
  }, []);

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (
        calendarRef.current &&
        !calendarRef.current.contains(event.target)
      ) {
        setIsExpanded(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  useEffect(() => {
    const fetchAndHandleReservations = async () => {
      if (startDate) {
        const beginDate = startDate.format('YYYY-MM-DD');
        const endDate = startDate.clone().add(13, 'days').format('YYYY-MM-DD');
        const restaurantId = localStorage.getItem('username');
        const endpoint = `${window.baseDomain}api/slots/${restaurantId}/${beginDate}/${endDate}`;

        try {
          console.log("Calendar Slots GET");
          const data = await api.get(endpoint, { noCache: true });
          setReservations(data); // Update local state with fetched reservations
          console.log('Fetched reservations:', data);

          if (onReservationsFetched && typeof onReservationsFetched === 'function') {
            onReservationsFetched(data); // Invoke callback with fetched data
          }
        } catch (error) {
          console.error('Error fetching reservations:', error);
        }
      }
    };

    fetchAndHandleReservations();
  }, [startDate, api, onReservationsFetched]);

  const generateCalendarDays = (startDate) => {
    const days = [];
    const today = moment().tz('Europe/Amsterdam').startOf('day');
    const twoWeeksFromStart = startDate.clone().add(13, 'days');

    let date = startDate.clone();
    while (date.isSameOrBefore(twoWeeksFromStart, 'day')) {
      const formattedDate = date.format('YYYY-MM-DD');
      const isAvailable = availableDates.includes(formattedDate);

      days.push({
        date: date.clone(),
        isPast: date.isBefore(today, 'day'),
        isFuture: date.isAfter(maxDate, 'day'),
        isAvailable: isAvailable,
      });

      date.add(1, 'day');
    }

    return days;
  };

  const handleDateClick = (day) => {
    if (day.isAvailable && !day.isPast && !day.isFuture) {
      const formattedDate = day.date.format('YYYY-MM-DD');
      onSelectDate(formattedDate); // Notify parent
      setIsExpanded(false);
    } else {
      console.log('Date is not available for selection.');
    }
  };

  const handlePrevWeek = () => {
    const newStartDate = startDate.clone().subtract(1, 'week');
    if (isWeekInPast(newStartDate)) {
      console.log('Cannot go to previous week. It is in the past.');
      return;
    }
    setStartDate(newStartDate);
  };

  const handleNextWeek = () => {
    const newStartDate = startDate.clone().add(1, 'week');
    setStartDate(newStartDate);
  };

  const formatDisplayDate = () => {
    if (!selectedDate) {
      return 'Selecteer een datum'; // "Select a date" in Dutch
    }

    const selectedMoment = moment(selectedDate, 'YYYY-MM-DD')
      .tz('Europe/Amsterdam')
      .startOf('day');
    const today = moment().tz('Europe/Amsterdam').startOf('day');
    const tomorrow = moment().tz('Europe/Amsterdam').add(1, 'day').startOf('day');

    if (selectedMoment.isSame(today, 'day')) {
      return 'Vandaag'; // "Today" in Dutch
    } else if (selectedMoment.isSame(tomorrow, 'day')) {
      return 'Morgen'; // "Tomorrow" in Dutch
    } else {
      // Format: e.g., "Maandag 1 Januari 2023"
      return selectedMoment.format('dddd D MMMM YYYY');
    }
  };

  const days = startDate ? generateCalendarDays(startDate) : [];

  return (
    <div className="calendar-container" ref={calendarRef}>
      <div
        className="calendar-display"
        onClick={() => {
          setIsExpanded(!isExpanded);
        }}
      >
        <span>{formatDisplayDate()}</span>
        <span className="arrow">
          <svg
            width="12"
            height="12"
            viewBox="0 0 24 24"
            style={{
              transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
              transition: 'transform 0.2s',
            }}
          >
            <path
              d="M7 10l5 5 5-5"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
            />
          </svg>
        </span>
      </div>
      {isExpanded && startDate && (
        <div className="calendar">
          <div className="calendar-header">
            <button type="button" onClick={handlePrevWeek}>
              &lt;
            </button>
            <span>
              {startDate.format('DD MMM')} -{' '}
              {startDate.clone().add(13, 'days').format('DD MMM YYYY')}
            </span>
            <button type="button" onClick={handleNextWeek}>
              &gt;
            </button>
          </div>
          <div className="calendar-weeks-wrapper">
            <table className="calendar-table">
              <thead>
                <tr>
                  {['Ma', 'Di', 'Wo', 'Do', 'Vr', 'Za', 'Zo'].map((day) => (
                    <th key={day}>{day}</th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {Array.from({ length: 2 }).map((_, weekIndex) => (
                  <tr key={weekIndex}>
                    {days
                      .slice(weekIndex * 7, weekIndex * 7 + 7)
                      .map((dayObj, index) => {
                        const isSelected =
                          selectedDate &&
                          isSameDay(
                            dayObj.date,
                            moment(selectedDate, 'YYYY-MM-DD').tz('Europe/Amsterdam')
                          );
                        const classNames = [];
                        if (dayObj.isPast) {
                          classNames.push('gray-out');
                        } else if (dayObj.isAvailable) {
                          classNames.push('available');
                        } else {
                          classNames.push('unavailable');
                        }
                        if (isSelected) {
                          classNames.push('selected');
                        }

                        return (
                          <td
                            key={index}
                            className={classNames.join(' ')}
                            onClick={() => handleDateClick(dayObj)}
                            style={{
                              '--animation-order': index + weekIndex * 7,
                            }}
                          >
                            <div className="day-square">
                              {dayObj.date.date()}
                            </div>
                          </td>
                        );
                      })}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}
    </div>
  );
};

export default Calendar;


--- StepOne/DateSelector.js ---
// src/Pages/NewReservation/DateSelector.jsx

import React, { useEffect, useState, useCallback } from 'react';
import Calendar from './Calendar';
import { generateAvailableDates } from './Utils/generateDates';
import moment from 'moment';

const DateSelector = ({
  guests,
  formData,
  handleChange,
  resetFormDataFields,
  timeblocks,
}) => {
  const [availableDates, setAvailableDates] = useState([]);
  const [reservations, setReservations] = useState([]); // New state for reservations

  useEffect(() => {
    if (Array.isArray(timeblocks)) {
      const dates = generateAvailableDates(guests, timeblocks, reservations);
      setAvailableDates(dates);
    } else {
      console.error('timeblocks is undefined or not an array:', timeblocks);
      setAvailableDates([]);
    }
  }, [formData.guests, timeblocks, reservations]);

  const handleDateSelect = (date) => {
    const formattedDate = moment(date).format('YYYY-MM-DD');
    console.log('Selected date:', formattedDate);
    handleChange({
      target: { name: 'date', value: formattedDate },
    });
    resetFormDataFields(['time']);
  };

  // Memoize the callback to prevent unnecessary re-renders
  const handleReservationsFetched = useCallback((data) => {
    setReservations(data); // Update the reservations state
  }, []);

  return (
    <div className="form-group date-selector-container">
      <Calendar
        availableDates={availableDates}
        selectedDate={formData.date || null}
        onSelectDate={handleDateSelect}
        autoExpand={false}
        onReservationsFetched={handleReservationsFetched} // Pass the handler as prop
      />
    </div>
  );
};

export default DateSelector;


--- StepOne/TimeSelector.js ---
// src/Pages/NewReservation/TimeSelector.jsx

import React, { useState, useEffect, useRef } from 'react';
import { generateAvailableTimesForDate } from './Utils/generateTimes';
import './css/timeSelector.css';

const TimeSelector = ({
  guests, 
  formData,
  handleChange,
  field,
  selectedDate,
  expanded,
  setCurrentExpandedField,
}) => {
  const [isExpanded, setIsExpanded] = useState(expanded || false);
  const [availableTimes, setAvailableTimes] = useState([]);
  const timeSelectorRef = useRef(null);

  useEffect(() => {
    if (selectedDate) {
      const times = generateAvailableTimesForDate(guests, new Date(selectedDate));
      setAvailableTimes(times);
    } else {
      setAvailableTimes([]);
    }
  }, [selectedDate]);

  const handleTimeSelect = (timeValue) => {
    handleChange({
      target: { name: field.id, value: timeValue },
    });
    setIsExpanded(false);
    if (setCurrentExpandedField) {
      setCurrentExpandedField(null);
    }
  };

  const formatDisplayTime = () => {
    if (formData[field.id]) {
      const selected = availableTimes.find((time) => time.value === formData[field.id]);
      return selected ? selected.label : 'Selecteer een tijd';
    }
    return 'Selecteer een tijd';
  };

  if (!field) {
    return null;
  }

  return (
    <div className="form-group time-selector-container" ref={timeSelectorRef}>

      {!selectedDate ? (
        <p className="info-text">Selecteer eerst een datum.</p>
      ) : (
        <>
          <div
            className="time-display"
            onClick={() => {
              setIsExpanded(!isExpanded);
              if (!isExpanded && setCurrentExpandedField) {
                setCurrentExpandedField('time');
              }
            }}
          >
            <span>{formatDisplayTime()}</span>
            <span className="arrow">
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                style={{
                  transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
                  transition: 'transform 0.2s',
                }}
              >
                <path
                  d="M7 10l5 5 5-5"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                />
              </svg>
            </span>
          </div>
          {isExpanded && (
            <div className="time-selector">
              {availableTimes.length === 0 ? (
                <div className="no-times">Geen beschikbare tijden.</div>
              ) : (
                <div className="time-options">
                  {availableTimes.map((time) => (
                    <div
                      key={time.value}
                      className={`time-option ${
                        formData[field.id] === time.value ? 'selected' : ''
                      }`}
                      onClick={() => handleTimeSelect(time.value)}
                    >
                      {time.label}
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}
        </>
      )}
    </div>
  );
};

export default TimeSelector;


--- StepOne/Utils/dateUtils.js ---
// src/Pages/NewReservation/Utils/dateUtils.js

import moment from 'moment-timezone';

export const isWeekInPast = (weekStartDate) => {
  const today = moment().tz('Europe/Brussels').startOf('day');
  const weekEndDate = weekStartDate.clone().add(6, 'days').endOf('day');
  return weekEndDate.isBefore(today);
};

export const isSameDay = (date1, date2) => date1.isSame(date2, 'day');


--- StepOne/Utils/dates/blockDates.js ---
// src/Pages/NewReservation/Utils/dates/blockDates.js

import { DateTime } from 'luxon';

const getOrInitializeArray = (dict, key) => {
  if (!Array.isArray(dict[key])) {
    dict[key] = [];
  }
  return dict[key];
};

const initializeDictionaries = () => {
  window.dateDictionary = window.dateDictionary || {};
  window.shiftsPerDate = window.shiftsPerDate || {};
};

const processTimeblock = (block) => {
  if (!block.date) {
    return;
  }

  const dateString = DateTime.fromISO(block.date, { zone: 'Europe/Brussels' }).toISODate();

  // Check if date is in closedDates
  if (window.closedDates.has(dateString)) {
    return;
  }

  // Check for exceptional openings
  if (window.exceptionalOpenings[dateString]) {
    const exceptionalOpening = window.exceptionalOpenings[dateString];
    window.dateDictionary[dateString] = [
      {
        startTime: exceptionalOpening.startTime,
        endTime: exceptionalOpening.endTime,
      },
    ];
  } else {
    // Use the block's times
    if (!window.dateDictionary[dateString]) {
      window.dateDictionary[dateString] = [];
    }
    window.dateDictionary[dateString].push({
      startTime: block.startTime || null,
      endTime: block.endTime || null,
    });
  }

  // Process shifts
  if (block.shifts && Array.isArray(block.shifts) && block.shifts.length > 0) {
    const shiftsArray = getOrInitializeArray(window.shiftsPerDate, dateString);

    block.shifts.forEach((shift) => {
      const exists = shiftsArray.some(
        (existingShift) =>
          existingShift.name === shift.name && existingShift.startTime === shift.startTime
      );
      if (!exists) {
        shiftsArray.push({
          name: shift.name || '',
          startTime: shift.startTime || '',
          endTime: shift.endTime || null,
        });
      }
    });
  }
};

export const getBlockSettingsDates = (timeblocks) => {
  initializeDictionaries();
  const dates = [];

  timeblocks.forEach((block) => {
    processTimeblock(block);
    // Do not add date if not in dateDictionary (i.e., date was skipped)
    if (block.date) {
      const dateString = DateTime.fromISO(block.date, { zone: 'Europe/Brussels' }).toISODate();
      if (window.dateDictionary[dateString]) {
        dates.push(dateString);
      }
    }
  });

  return dates;
};


--- StepOne/Utils/dates/schemeDates.js ---
// src/Pages/NewReservation/Utils/dates/schemeDates.js

import { DateTime } from 'luxon';

const getOrInitializeArray = (dict, key) => {
  if (!Array.isArray(dict[key])) {
    dict[key] = [];
  }
  return dict[key];
};

const initializeDictionaries = () => {
  window.dateDictionary = window.dateDictionary || {};
  window.shiftsPerDate = window.shiftsPerDate || {};
};

const isWithinPeriod = (currentDate, endDate) => {
  return currentDate <= endDate;
};

const processDaySetting = (dateString, daySetting) => {
  // Check if date is in closedDates
  if (window.closedDates.has(dateString)) {
    return;
  }

  // Check for exceptional openings
  if (window.exceptionalOpenings[dateString]) {
    const exceptionalOpening = window.exceptionalOpenings[dateString];
    window.dateDictionary[dateString] = [
      {
        startTime: exceptionalOpening.startTime,
        endTime: exceptionalOpening.endTime,
      },
    ];
  } else {
    // Use the daySetting's times
    if (!window.dateDictionary[dateString]) {
      window.dateDictionary[dateString] = [];
    }
    window.dateDictionary[dateString].push({
      startTime: daySetting.startTime || null,
      endTime: daySetting.endTime || null,
    });
  }

  // Process shifts
  if (
    daySetting.shiftsEnabled &&
    Array.isArray(daySetting.shifts) &&
    daySetting.shifts.length > 0
  ) {
    const shiftsArray = getOrInitializeArray(window.shiftsPerDate, dateString);

    daySetting.shifts.forEach((shift) => {
      const exists = shiftsArray.some(
        (existingShift) =>
          existingShift.name === shift.name && existingShift.startTime === shift.startTime
      );
      if (!exists) {
        shiftsArray.push({
          name: shift.name || '',
          startTime: shift.startTime || '',
          endTime: shift.endTime || null,
        });
      }
    });
  }
};

export const getSchemeSettingsDates = (timeblocks, maxDate) => {
  initializeDictionaries();
  const dates = [];
  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

  timeblocks.forEach((block) => {
    if (!block.schemeSettings) {
      return;
    }

    const { schemeSettings } = block;
    let currentDate = DateTime.now().setZone('Europe/Brussels').startOf('day');

    // Adjust endDate based on dagenInToekomst
    let endDate = maxDate;

    if (schemeSettings.period && schemeSettings.period.enabled) {
      const { startDate, endDate: periodEndDate } = schemeSettings.period;
      if (startDate && periodEndDate) {
        currentDate = DateTime.fromISO(startDate, { zone: 'Europe/Brussels' }).startOf('day');
        const schemeEndDate = DateTime.fromISO(periodEndDate, { zone: 'Europe/Brussels' }).endOf('day');
        // Use the minimum of schemeEndDate and maxDate
        endDate = schemeEndDate < maxDate ? schemeEndDate : maxDate;
      }
    }

    while (isWithinPeriod(currentDate, endDate)) {
      const dayOfWeek = currentDate.weekday % 7;
      const dayName = dayNames[dayOfWeek];
      const daySetting = schemeSettings[dayName];
      const dateString = currentDate.toISODate();
      if (daySetting && daySetting.enabled) {
        processDaySetting(dateString, daySetting);
        if (window.dateDictionary[dateString]) {
          dates.push(dateString);
        }
      }
      currentDate = currentDate.plus({ days: 1 });
    }
  });
  return dates;
};


--- StepOne/Utils/exceptions.js ---
// Utils/exceptions.js

import { DateTime } from 'luxon';

export const collectExceptions = (timeblocks) => {
    // Initialize global exception containers
    window.closedDates = new Set();
    window.exceptionalOpenings = {};
    window.uitzonderlijkeCapaciteit = {}; // Initialize capaciteit exceptions

    timeblocks.forEach((block) => {
        if (!block.exceptionalDays) {
            return;
        }

        const { exceptionalDays } = block;

        // Process sluitingsperiode (closing periods)
        if (Array.isArray(exceptionalDays.sluitingsperiode)) {
            exceptionalDays.sluitingsperiode.forEach((period) => {
                if (period.enabled) {
                    const { startDate, endDate } = period;
                    if (startDate && endDate) {
                        let currentDate = DateTime.fromISO(startDate, { zone: "Europe/Brussels" }).startOf('day');
                        const endDateObj = DateTime.fromISO(endDate, { zone: "Europe/Brussels" }).startOf('day');
                        while (currentDate <= endDateObj) {
                            const dateString = currentDate.toISODate();
                            window.closedDates.add(dateString);
                            console.log(`[collectExceptions] Adding ${dateString} to closedDates due to sluitingsperiode.`);
                            currentDate = currentDate.plus({ days: 1 });
                        }
                    }
                }
            });
        }

        // Process uitzonderlijkeOpeningsuren (exceptional opening hours)
        if (Array.isArray(exceptionalDays.uitzonderlijkeOpeningsuren)) {
            exceptionalDays.uitzonderlijkeOpeningsuren.forEach((opening) => {
                if (opening.enabled) {
                    const { date, startTime, endTime } = opening;
                    if (date && startTime && endTime) {
                        window.exceptionalOpenings[date] = {
                            startTime,
                            endTime,
                        };
                        console.log(`[collectExceptions] Adding exceptional opening for ${date}: ${startTime} - ${endTime}`);
                    }
                }
            });
        }

        // Process uitzonderlijkeCapaciteit (exceptional capacity)
        if (Array.isArray(exceptionalDays.uitzonderlijkeCapaciteit)) {
            exceptionalDays.uitzonderlijkeCapaciteit.forEach((capacityEntry) => {
                if (capacityEntry.enabled) {
                    const { date, capacity } = capacityEntry;
                    if (date && capacity !== undefined && capacity !== null) {
                        // Convert capacity to a number if it's a string
                        const numericCapacity = Number(capacity);
                        if (!isNaN(numericCapacity)) {
                            window.uitzonderlijkeCapaciteit[date] = numericCapacity;
                            console.log(`[collectExceptions] Setting exceptional capacity for ${date}: ${numericCapacity}`);
                        } else {
                            console.warn(`[collectExceptions] Invalid capacity value for ${date}: ${capacity}`);
                        }
                    }
                }
            });
        }
    });
};


--- StepOne/Utils/generateDates.js ---
// Utils/generateDates.js

import { DateTime } from 'luxon';
import { collectExceptions } from './exceptions';
import { getSchemeSettingsDates } from './dates/schemeDates';
import { getBlockSettingsDates } from './dates/blockDates';
import { generateAvailableTimesForDate } from './generateTimes'; // Ensure correct import path

const initializeDictionaries = () => {
    window.dateDictionary = window.dateDictionary || {};
    window.shiftsPerDate = window.shiftsPerDate || {};
};

export const generateAvailableDates = (guests, timeblocks = [], reservations = []) => {
    initializeDictionaries();
    collectExceptions(timeblocks);

    const dagenInToekomstRaw = window.generalSettings?.dagenInToekomst;
    let dagenInToekomst = 365;

    if (dagenInToekomstRaw) {
        if (typeof dagenInToekomstRaw === 'number') {
            dagenInToekomst = dagenInToekomstRaw;
        } else if (typeof dagenInToekomstRaw === 'string') {
            dagenInToekomst = parseInt(dagenInToekomstRaw, 10);
            if (isNaN(dagenInToekomst)) {
                dagenInToekomst = 365;
            }
        }
    }

    const today = DateTime.now().setZone("Europe/Brussels").startOf('day');
    const maxDate = today.plus({ days: dagenInToekomst - 1 }).endOf('day'); // Subtract 1 because we count today as day 1

    const blockDates = getBlockSettingsDates(timeblocks);
    const schemeDates = getSchemeSettingsDates(timeblocks, maxDate);
    const combinedDates = [...blockDates, ...schemeDates];

    const filteredDates = combinedDates.filter(dateStr => {
        const date = DateTime.fromISO(dateStr, { zone: "Europe/Brussels" }).startOf('day');
        return date >= today && date <= maxDate;
    });

    let uniqueDates = Array.from(new Set(filteredDates)).sort();

    // Initialize countingDictionary
    const countingDictionary = {};

    // Retrieve intervalReservatie and validate it
    const intervalReservatie = window.generalSettings?.intervalReservatie;
    let intervalMinutes = 30; // Default value

    if (
        typeof intervalReservatie === 'number' &&
        Number.isInteger(intervalReservatie) &&
        intervalReservatie > 0
    ) {
        intervalMinutes = intervalReservatie;
    } else {
        console.warn(
            `[generateAvailableDates] Invalid intervalReservatie value "${intervalReservatie}". Using default intervalMinutes = 30`
        );
    }

    // Retrieve duurReservatie and validate it
    const duurReservatieRaw = window.generalSettings?.duurReservatie;
    let duurReservatieMinutes = 120; // Default duration in minutes (2 hours)

    if (
        typeof duurReservatieRaw === 'number' &&
        Number.isInteger(duurReservatieRaw) &&
        duurReservatieRaw > 0
    ) {
        duurReservatieMinutes = duurReservatieRaw;
    } else {
        console.warn(
            `[generateAvailableDates] Invalid duurReservatie value "${duurReservatieRaw}". Using default duurReservatieMinutes = 120`
        );
    }

    // Retrieve uurOpVoorhand and validate it
    let uurOpVoorhand = 0; // Default value

    // Function to generate times for a given dateKey
    const generateAvailableTimesForDateKey = (guests, dateKey) => {
        const dateDictionary = window.dateDictionary;
        const shiftsPerDate = window.shiftsPerDate;
        const selectedDate = DateTime.fromISO(dateKey, { zone: "Europe/Brussels" });

        if (!dateDictionary[dateKey] || dateDictionary[dateKey].length === 0) {
            return [];
        }

        const shiftData =
            shiftsPerDate && Array.isArray(shiftsPerDate[dateKey]) ? shiftsPerDate[dateKey] : [];

        if (shiftData.length > 0) {
            const shiftButtons = shiftData.map((shift) => ({
                label: shift.name,
                value: shift.startTime,
            }));
            return shiftButtons.map(button => button.value);
        }

        const times = [];

        dateDictionary[dateKey].forEach(({ startTime, endTime }) => {

            let startDateTime = DateTime.fromFormat(startTime, 'HH:mm', { zone: "Europe/Brussels" }).set({
                year: selectedDate.year,
                month: selectedDate.month,
                day: selectedDate.day
            });

            const endDateTime = DateTime.fromFormat(endTime, 'HH:mm', { zone: "Europe/Brussels" }).set({
                year: selectedDate.year,
                month: selectedDate.month,
                day: selectedDate.day
            });

            while (startDateTime < endDateTime) {
                const timeString = startDateTime.toFormat('HH:mm');
                times.push(timeString);
                startDateTime = startDateTime.plus({ minutes: intervalMinutes });
            }
        });

        const uniqueTimes = [...new Set(times)].sort(
            (a, b) => DateTime.fromFormat(a, 'HH:mm') - DateTime.fromFormat(b, 'HH:mm')
        );

        return uniqueTimes;
    };

    // Generate countingDictionary with initial counts
    uniqueDates.forEach(dateKey => {
        const times = generateAvailableTimesForDateKey(guests, dateKey);
        countingDictionary[dateKey] = {};

        times.forEach(time => {
            countingDictionary[dateKey][time] = 0;
        });
    });

    // Process reservations to update counts
    reservations.forEach(reservation => {
        const reservationDate = reservation.date; // string in "YYYY-MM-DD" format
        const reservationTime = reservation.time; // string in "HH:mm"
        const numberOfGuests = reservation.guests;

        if (countingDictionary[reservationDate]) {
            const resStartDateTime = DateTime.fromISO(`${reservationDate}T${reservationTime}`, { zone: "Europe/Brussels" });

            // Use duurReservatieMinutes instead of fixed 2 hours
            const resEndDateTime = resStartDateTime.plus({ minutes: duurReservatieMinutes });

            // For each time period in countingDictionary[reservationDate]
            Object.keys(countingDictionary[reservationDate]).forEach(timePeriodStart => {
                const timePeriodStartDateTime = DateTime.fromISO(`${reservationDate}T${timePeriodStart}`, { zone: "Europe/Brussels" });
                const timePeriodEndDateTime = timePeriodStartDateTime.plus({ minutes: intervalMinutes });

                // Check if reservation interval collides with time period
                if (resStartDateTime < timePeriodEndDateTime && resEndDateTime > timePeriodStartDateTime) {
                    // There is a collision
                    countingDictionary[reservationDate][timePeriodStart] += numberOfGuests;
                }
            });
        }
    });

    // Print the countingDictionary
    console.log('[generateAvailableDates] Counting Dictionary:', countingDictionary);

    // Store countingDictionary in window for access in generateAvailableTimesForDate
    window.countingDictionary = countingDictionary;

    // Remove dates with no available time buttons
    const datesToRemove = [];
    uniqueDates.forEach(dateKey => {
        const selectedDate = DateTime.fromISO(dateKey, { zone: "Europe/Brussels" }).toJSDate();
        const availableTimeButtons = generateAvailableTimesForDate(guests, selectedDate);

        if (availableTimeButtons.length === 0) {
            datesToRemove.push(dateKey);
        }
    });

    // Filter out the dates to remove
    uniqueDates = uniqueDates.filter(dateKey => !datesToRemove.includes(dateKey));

    // Print the final uniqueDates
    console.log('[generateAvailableDates] Final Unique Dates:', uniqueDates);

    return uniqueDates;
};


--- StepOne/Utils/generateTimes.js ---
// generateTimes.js

import { DateTime } from 'luxon';

const formatDateKey = (date) => {
    const formattedDate = DateTime.fromJSDate(date).toISODate();
    return formattedDate;
};

export const generateAvailableTimesForDate = (guests, selectedDate) => {
    const dateDictionary = window.dateDictionary;
    const shiftsPerDate = window.shiftsPerDate;
    const dateKey = formatDateKey(selectedDate);

    // Retrieve intervalReservatie and validate it
    const intervalReservatie = window.generalSettings?.intervalReservatie;
    let intervalMinutes = 30; // Default value

    if (
        typeof intervalReservatie === 'number' &&
        Number.isInteger(intervalReservatie) &&
        intervalReservatie > 0
    ) {
        intervalMinutes = intervalReservatie;
    } else {
        console.warn(
            `[generateAvailableTimesForDate] Invalid intervalReservatie value "${intervalReservatie}". Using default intervalMinutes = 30`
        );
    }

    if (!dateDictionary[dateKey] || dateDictionary[dateKey].length === 0) {
        return [];
    }

    const shiftData =
        shiftsPerDate && Array.isArray(shiftsPerDate[dateKey]) ? shiftsPerDate[dateKey] : [];

    let timeButtons = [];

    if (shiftData.length > 0) {
        timeButtons = shiftData.map((shift) => ({
            label: shift.name,
            value: shift.startTime,
        }));
    } else {
        const times = [];

        dateDictionary[dateKey].forEach(({ startTime, endTime }) => {

            let startDateTime = DateTime.fromFormat(startTime, 'HH:mm', { zone: "Europe/Brussels" }).set({
                year: selectedDate.getFullYear(),
                month: selectedDate.getMonth() + 1,
                day: selectedDate.getDate()
            });

            const endDateTime = DateTime.fromFormat(endTime, 'HH:mm', { zone: "Europe/Brussels" }).set({
                year: selectedDate.getFullYear(),
                month: selectedDate.getMonth() + 1,
                day: selectedDate.getDate()
            });

            while (startDateTime < endDateTime) {
                const timeString = startDateTime.toFormat('HH:mm');
                times.push(timeString);

                startDateTime = startDateTime.plus({ minutes: intervalMinutes });
            }
        });

        const uniqueTimes = [...new Set(times)].sort(
            (a, b) => DateTime.fromFormat(a, 'HH:mm') - DateTime.fromFormat(b, 'HH:mm')
        );

        timeButtons = uniqueTimes.map((time) => ({
            label: time,
            value: time,
        }));
    }

    // Determine capacityLimit: use uitzonderlijkeCapaciteit if defined, else use general zitplaatsen
    const uitzonderlijkeCapaciteit = window.uitzonderlijkeCapaciteit || {};
    const exceptionalCapacity = uitzonderlijkeCapaciteit[dateKey];
    const capacityLimit = (typeof exceptionalCapacity === 'number') 
        ? exceptionalCapacity 
        : (window.generalSettings?.zitplaatsen || 0);

    if (typeof capacityLimit !== 'number' || capacityLimit < 0) {
        console.warn(
            `[generateAvailableTimesForDate] Invalid capacityLimit value "${capacityLimit}". Defaulting to 0.`
        );
    }

    const finalCapacityLimit = (typeof capacityLimit === 'number' && capacityLimit >= 0) 
        ? capacityLimit 
        : 0;

    // Filter timeButtons based on countingDictionary and capacityLimit
    const countingDictionary = window.countingDictionary || {};

    if (countingDictionary[dateKey]) {
        timeButtons = timeButtons.filter(button => {
            const time = button.value;
            const guestsCount = countingDictionary[dateKey][time] || 0;     
            return (guestsCount + guests) <= finalCapacityLimit;
        });
    }

    return timeButtons;
};


--- StepOne/ValueSelector.js ---
// src/Pages/NewReservation/ValueSelector.jsx

import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import './css/valueSelector.css';

const ValueSelectorGuests = ({ setGuests, value, onChange }) => {
  const predefinedValues = [1, 2, 3, '4+'];
  const [selectedValue, setSelectedValue] = useState(value || '');
  const [showSlider, setShowSlider] = useState(false);

  const handlePredefinedValueClick = (val) => {
    if (val === '4+') {
      setShowSlider(true);
      setSelectedValue(4);
      setGuests(4);
      onChange({ target: { name: 'guests', value: 4 } });
    } else {
      setShowSlider(false);
      setSelectedValue(val);
      setGuests(val);
      onChange({ target: { name: 'guests', value: val } });
    }
  };

  const handleSliderChange = (e) => {
    const val = e.target.value;
    setSelectedValue(val);
    setGuests(val);
    onChange({ target: { name: 'guests', value: val } });
  };

  const handleInputChange = (e) => {
    const val = e.target.value;
    setSelectedValue(val);
    setGuests(val);
    onChange({ target: { name: 'guests', value: val } });
  };

  return (
    <div className="value-selector">
      <div className="predefined-values">
        {predefinedValues.map((val) => (
          <button
            key={val}
            type="button"
            className={`predefined-value-button ${
              selectedValue == val || (val === '4+' && showSlider) ? 'active' : ''
            }`}
            onClick={() => handlePredefinedValueClick(val)}
          >
            {val === '4+' ? '4+' : `${val} ${val === 1 ? 'p' : 'p'}`}
          </button>
        ))}
      </div>
      <AnimatePresence>
        {showSlider && (
          <motion.div
            className="slider-container"
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
          >
            <input
              type="range"
              min="4"
              max="15"
              step="1"
              value={selectedValue}
              onChange={handleSliderChange}
              className="slider"
            />
            <input
              type="number"
              name="guests"
              value={selectedValue}
              onChange={handleInputChange}
              className="value-input"
              min="4"
              max="100"
              step="1"
            />
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default ValueSelectorGuests;


--- StepOne/index.js ---
// src/Pages/NewReservation/ReservationStepOne.jsx

import React, { useState, useEffect } from 'react';
import ValueSelectorGuests from './ValueSelector';
import DateSelector from './DateSelector';
import TimeSelector from './TimeSelector';

const ReservationStepOne = ({
  formData,
  errors,
  handleChange,
  handleStepOneSubmit,
  setFormData,
  timeblocks,
  loadingTimeblocks,
  timeblocksError,
}) => {
  const [guests, setGuests] = useState(1);
  
  const resetFormDataFields = (fieldsToReset) => {
    setFormData((prevFormData) => {
      const newFormData = { ...prevFormData };
      fieldsToReset.forEach((field) => {
        newFormData[field] = '';
      });
      return newFormData;
    });
  };

  useEffect(() => {
      resetFormDataFields(['date', 'time']);
  }, [guests]);



  if (timeblocksError) {
    return (
      <div>
        <a
          href="https://dashboard.reservaties.net/#/scheme"
          target="_blank"
          rel="noopener noreferrer"
          style={{ color: 'var(--color-blue)', textDecoration: 'underline' }}
        >
          Klik hier
        </a>{' '}
        om uw openingsuren in te stellen.
      </div>
    );
  }

  return (
    <form className="account-manage-form" onSubmit={handleStepOneSubmit} noValidate>
      <ValueSelectorGuests
        setGuests={setGuests}
        value={formData.guests}
        onChange={handleChange}
        error={errors.guests}
      />

      {formData.guests && (
        <DateSelector
          guests={formData.guests}
          formData={formData}
          handleChange={handleChange}
          resetFormDataFields={resetFormDataFields}
          timeblocks={timeblocks}
        />
      )}

      {formData.date && (
        <TimeSelector
          guests={formData.guests}
          formData={formData}
          handleChange={handleChange}
          field={{ id: 'time', label: 'Tijd' }}
          selectedDate={formData.date}
        />
      )}
    </form>
  );
};

export default ReservationStepOne;


--- index.js ---
import React, { useState } from 'react';
import useApi from '../../Hooks/useApi';
import ReservationSidebar from './ReservationSidebar';
import { AiOutlinePlus } from 'react-icons/ai';

import './css/newReservationAdmin.css';

const NewReservationAdmin = () => {
  const api = useApi();

  const [formData, setFormData] = useState({
    guests: '',
    date: '',
    time: '',
    menu: '', // Add this line
    firstName: '',
    lastName: '',
    email: '',
    phone: '',
    extraInfo: '',
    notes: '',
  });

  const [errors, setErrors] = useState({});

  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [reservationSubmitted, setReservationSubmitted] = useState(false);

  const validateStepOne = () => {
    const errors = {};
    if (!formData.guests) {
      errors.guests = 'Aantal gasten is verplicht';
    }
    if (!formData.date) {
      errors.date = 'Datum is verplicht';
    }
    if (!formData.time) {
      errors.time = 'Tijd is verplicht';
    }
    return errors;
  };

  const validateStepTwo = () => {
    const errors = {};

    if (formData.email && !/\S+@\S+\.\S+/.test(formData.email)) {
      errors.email = 'E-mail is ongeldig';
    }

    return errors;
  };

  const handleFinalSubmit = async (e) => {
    e.preventDefault();
    const stepOneErrors = validateStepOne();
    const stepTwoErrors = validateStepTwo();
    const allErrors = { ...stepOneErrors, ...stepTwoErrors };
    if (Object.keys(allErrors).length > 0) {
      setErrors(allErrors);
    } else {
      setErrors({});
      setIsSubmitting(true);
      const submissionData = {
        guests: formData.guests,
        date: formData.date,
        time: formData.time,
        firstName: formData.firstName,
        lastName: formData.lastName,
        email: formData.email,
        phone: formData.phone,
        extraInfo: formData.extraInfo,
        notes: formData.notes,
      };

      try {
        await api.post(`${window.baseDomain}api/auth-reservations/`, submissionData);
        setReservationSubmitted(true);
      } catch (error) {
        console.error('Error submitting reservation:', error);
      } finally {
        setIsSubmitting(false);
      }
    }
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({ ...formData, [name]: value });
    setErrors({ ...errors, [name]: '' });
  };

  return (
    <div className="new-reservation-page">
      <button
        className="open-sidebar-button"
        onClick={() => setIsSidebarOpen(true)}
        style={{ zIndex: isSidebarOpen ? 0 : 1000 }}
      >
        <AiOutlinePlus size={24} color="#fff" />
      </button>
      {/* Sidebar */}
      <ReservationSidebar
        isOpen={isSidebarOpen}
        onClose={() => setIsSidebarOpen(false)}
        formData={formData}
        errors={errors}
        handleChange={handleChange}
        handleFinalSubmit={handleFinalSubmit}
        setFormData={setFormData}
        isSubmitting={isSubmitting}
        reservationSubmitted={reservationSubmitted}
        onNewReservation={() => {
          setFormData({
            guests: '',
            date: '',
            time: '',
            firstName: '',
            lastName: '',
            email: '',
            phone: '',
            extraInfo: '',
            notes: '',
          });
          setReservationSubmitted(false);
        }}
      />
    </div>
  );
};

export default NewReservationAdmin;



Directory Structure for "/Users/thibaultvandesompele/Desktop/Mateza 4.0/Client/Dashboard/dashboard-general/src/Pages/NewReservation":

├── FormField.js
├── ReservationSidebar.js
├── ReservationStepTwo.js
├── ReservationSummary.js
├── StepOne
│   ├── Calendar.js
│   ├── DateSelector.js
│   ├── TimeSelector.js
│   ├── Utils
│   │   ├── dateUtils.js
│   │   ├── dates
│   │   │   ├── blockDates.js
│   │   │   └── schemeDates.js
│   │   ├── exceptions.js
│   │   ├── generateDates.js
│   │   └── generateTimes.js
│   ├── ValueSelector.js
│   ├── css
│   │   ├── calendar.css
│   │   ├── timeSelector.css
│   │   └── valueSelector.css
│   └── index.js
├── css
│   ├── newReservationAdmin.css
│   ├── reservationSidebar.css
│   ├── reservationSummary.css
│   └── reservationsStepTwo.css
└── index.js


List of Files:
FormField.js
ReservationSidebar.js
ReservationStepTwo.js
ReservationSummary.js
StepOne/Calendar.js
StepOne/DateSelector.js
StepOne/TimeSelector.js
StepOne/Utils/dateUtils.js
StepOne/Utils/dates/blockDates.js
StepOne/Utils/dates/schemeDates.js
StepOne/Utils/exceptions.js
StepOne/Utils/generateDates.js
StepOne/Utils/generateTimes.js
StepOne/ValueSelector.js
StepOne/index.js
index.js

**Instruction:**
1. Please encapsulate the main component in index.js inside the `.component-name-component` class.
2. Prefix all CSS classes with the `.component-name-component` class. Sometimes the encapsulation is already done, and we don't need to do it twice. Don't write any comments. Delete all comments and don't write any extra comments. Only print the code with changes. Print the codes in full. Don't skip anything print them full. Mark all changed files with CHANGED before printing the file else mark them with --unchanged and don't print them. Only print every file once.

**Note:** CSS files have been excluded from this prompt.