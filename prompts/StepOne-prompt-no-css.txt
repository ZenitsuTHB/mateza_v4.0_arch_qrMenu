File Contents:

--- Calendar.js ---
// src/Pages/NewReservation/Calendar.jsx

import React, { useState, useEffect, useRef } from 'react';
import moment from 'moment-timezone';
import 'moment/locale/nl';
import { isWeekInPast, isSameDay } from './Utils/dateUtils';
import './css/calendar.css';
import useApi from '../../../Hooks/useApi';

moment.locale('nl'); // Set moment to Dutch locale

const Calendar = ({
  availableDates,
  selectedDate,
  onSelectDate,
  autoExpand,
  onReservationsFetched, // New prop for callback
}) => {
  const [isExpanded, setIsExpanded] = useState(autoExpand || false);
  const [startDate, setStartDate] = useState(null);
  const [reservations, setReservations] = useState(null); // Local state for reservations
  const calendarRef = useRef(null);
  const api = useApi(); // Initialize useApi hook

  const maxDate = moment().tz('Europe/Amsterdam').add(1, 'year').endOf('day');

  useEffect(() => {
    if (autoExpand) {
      setIsExpanded(true);
    }
  }, [autoExpand]);

  useEffect(() => {
    const today = moment().tz('Europe/Amsterdam').startOf('day');
    let firstWeekStart = today.clone().startOf('isoWeek');
    while (isWeekInPast(firstWeekStart)) {
      firstWeekStart.add(1, 'week');
    }
    setStartDate(firstWeekStart);
  }, []);

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (
        calendarRef.current &&
        !calendarRef.current.contains(event.target)
      ) {
        setIsExpanded(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  useEffect(() => {
    const fetchAndHandleReservations = async () => {
      if (startDate) {
        const beginDate = startDate.format('YYYY-MM-DD');
        const endDate = startDate.clone().add(13, 'days').format('YYYY-MM-DD');
        const restaurantId = localStorage.getItem('username');
        const endpoint = `${window.baseDomain}api/slots/${restaurantId}/${beginDate}/${endDate}`;

        try {
          console.log("Calendar Slots GET");
          const data = await api.get(endpoint, { noCache: true });
          setReservations(data); // Update local state with fetched reservations
          console.log('Fetched reservations:', data);

          if (onReservationsFetched && typeof onReservationsFetched === 'function') {
            onReservationsFetched(data); // Invoke callback with fetched data
          }
        } catch (error) {
          console.error('Error fetching reservations:', error);
        }
      }
    };

    fetchAndHandleReservations();
  }, [startDate, api, onReservationsFetched]);

  const generateCalendarDays = (startDate) => {
    const days = [];
    const today = moment().tz('Europe/Amsterdam').startOf('day');
    const twoWeeksFromStart = startDate.clone().add(13, 'days');

    let date = startDate.clone();
    while (date.isSameOrBefore(twoWeeksFromStart, 'day')) {
      const formattedDate = date.format('YYYY-MM-DD');
      const isAvailable = availableDates.includes(formattedDate);

      days.push({
        date: date.clone(),
        isPast: date.isBefore(today, 'day'),
        isFuture: date.isAfter(maxDate, 'day'),
        isAvailable: isAvailable,
      });

      date.add(1, 'day');
    }

    return days;
  };

  const handleDateClick = (day) => {
    if (day.isAvailable && !day.isPast && !day.isFuture) {
      const formattedDate = day.date.format('YYYY-MM-DD');
      onSelectDate(formattedDate); // Notify parent
      setIsExpanded(false);
    } else {
      console.log('Date is not available for selection.');
    }
  };

  const handlePrevWeek = () => {
    const newStartDate = startDate.clone().subtract(1, 'week');
    if (isWeekInPast(newStartDate)) {
      console.log('Cannot go to previous week. It is in the past.');
      return;
    }
    setStartDate(newStartDate);
  };

  const handleNextWeek = () => {
    const newStartDate = startDate.clone().add(1, 'week');
    setStartDate(newStartDate);
  };

  const formatDisplayDate = () => {
    if (!selectedDate) {
      return 'Selecteer een datum'; // "Select a date" in Dutch
    }

    const selectedMoment = moment(selectedDate, 'YYYY-MM-DD')
      .tz('Europe/Amsterdam')
      .startOf('day');
    const today = moment().tz('Europe/Amsterdam').startOf('day');
    const tomorrow = moment().tz('Europe/Amsterdam').add(1, 'day').startOf('day');

    if (selectedMoment.isSame(today, 'day')) {
      return 'Vandaag'; // "Today" in Dutch
    } else if (selectedMoment.isSame(tomorrow, 'day')) {
      return 'Morgen'; // "Tomorrow" in Dutch
    } else {
      // Format: e.g., "Maandag 1 Januari 2023"
      return selectedMoment.format('dddd D MMMM YYYY');
    }
  };

  const days = startDate ? generateCalendarDays(startDate) : [];

  return (
    <div className="calendar-container" ref={calendarRef}>
      <div
        className="calendar-display"
        onClick={() => {
          setIsExpanded(!isExpanded);
        }}
      >
        <span>{formatDisplayDate()}</span>
        <span className="arrow">
          <svg
            width="12"
            height="12"
            viewBox="0 0 24 24"
            style={{
              transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
              transition: 'transform 0.2s',
            }}
          >
            <path
              d="M7 10l5 5 5-5"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
            />
          </svg>
        </span>
      </div>
      {isExpanded && startDate && (
        <div className="calendar">
          <div className="calendar-header">
            <button type="button" onClick={handlePrevWeek}>
              &lt;
            </button>
            <span>
              {startDate.format('DD MMM')} -{' '}
              {startDate.clone().add(13, 'days').format('DD MMM YYYY')}
            </span>
            <button type="button" onClick={handleNextWeek}>
              &gt;
            </button>
          </div>
          <div className="calendar-weeks-wrapper">
            <table className="calendar-table">
              <thead>
                <tr>
                  {['Ma', 'Di', 'Wo', 'Do', 'Vr', 'Za', 'Zo'].map((day) => (
                    <th key={day}>{day}</th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {Array.from({ length: 2 }).map((_, weekIndex) => (
                  <tr key={weekIndex}>
                    {days
                      .slice(weekIndex * 7, weekIndex * 7 + 7)
                      .map((dayObj, index) => {
                        const isSelected =
                          selectedDate &&
                          isSameDay(
                            dayObj.date,
                            moment(selectedDate, 'YYYY-MM-DD').tz('Europe/Amsterdam')
                          );
                        const classNames = [];
                        if (dayObj.isPast) {
                          classNames.push('gray-out');
                        } else if (dayObj.isAvailable) {
                          classNames.push('available');
                        } else {
                          classNames.push('unavailable');
                        }
                        if (isSelected) {
                          classNames.push('selected');
                        }

                        return (
                          <td
                            key={index}
                            className={classNames.join(' ')}
                            onClick={() => handleDateClick(dayObj)}
                            style={{
                              '--animation-order': index + weekIndex * 7,
                            }}
                          >
                            <div className="day-square">
                              {dayObj.date.date()}
                            </div>
                          </td>
                        );
                      })}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}
    </div>
  );
};

export default Calendar;


--- DateSelector.js ---
// src/Pages/NewReservation/DateSelector.jsx

import React, { useEffect, useState, useCallback } from 'react';
import Calendar from './Calendar';
import { generateAvailableDates } from './Utils/generateDates';
import moment from 'moment';

const DateSelector = ({
  guests,
  formData,
  handleChange,
  resetFormDataFields,
  timeblocks,
}) => {
  const [availableDates, setAvailableDates] = useState([]);
  const [reservations, setReservations] = useState([]); // New state for reservations

  useEffect(() => {
    if (Array.isArray(timeblocks)) {
      const dates = generateAvailableDates(guests, timeblocks, reservations);
      setAvailableDates(dates);
    } else {
      console.error('timeblocks is undefined or not an array:', timeblocks);
      setAvailableDates([]);
    }
  }, [formData.guests, timeblocks, reservations]);

  const handleDateSelect = (date) => {
    const formattedDate = moment(date).format('YYYY-MM-DD');
    console.log('Selected date:', formattedDate);
    handleChange({
      target: { name: 'date', value: formattedDate },
    });
    resetFormDataFields(['time']);
  };

  // Memoize the callback to prevent unnecessary re-renders
  const handleReservationsFetched = useCallback((data) => {
    setReservations(data); // Update the reservations state
  }, []);

  return (
    <div className="form-group date-selector-container">
      <Calendar
        availableDates={availableDates}
        selectedDate={formData.date || null}
        onSelectDate={handleDateSelect}
        autoExpand={false}
        onReservationsFetched={handleReservationsFetched} // Pass the handler as prop
      />
    </div>
  );
};

export default DateSelector;


--- TimeSelector.js ---
// src/Pages/NewReservation/TimeSelector.jsx

import React, { useState, useEffect, useRef } from 'react';
import { generateAvailableTimesForDate } from './Utils/generateTimes';
import './css/timeSelector.css';

const TimeSelector = ({
  guests, 
  formData,
  handleChange,
  field,
  selectedDate,
  expanded,
  setCurrentExpandedField,
}) => {
  const [isExpanded, setIsExpanded] = useState(expanded || false);
  const [availableTimes, setAvailableTimes] = useState([]);
  const timeSelectorRef = useRef(null);

  useEffect(() => {
    if (selectedDate) {
      const times = generateAvailableTimesForDate(guests, new Date(selectedDate));
      setAvailableTimes(times);
    } else {
      setAvailableTimes([]);
    }
  }, [selectedDate]);

  const handleTimeSelect = (timeValue) => {
    handleChange({
      target: { name: field.id, value: timeValue },
    });
    setIsExpanded(false);
    if (setCurrentExpandedField) {
      setCurrentExpandedField(null);
    }
  };

  const formatDisplayTime = () => {
    if (formData[field.id]) {
      const selected = availableTimes.find((time) => time.value === formData[field.id]);
      return selected ? selected.label : 'Selecteer een tijd';
    }
    return 'Selecteer een tijd';
  };

  if (!field) {
    return null;
  }

  return (
    <div className="form-group time-selector-container" ref={timeSelectorRef}>

      {!selectedDate ? (
        <p className="info-text">Selecteer eerst een datum.</p>
      ) : (
        <>
          <div
            className="time-display"
            onClick={() => {
              setIsExpanded(!isExpanded);
              if (!isExpanded && setCurrentExpandedField) {
                setCurrentExpandedField('time');
              }
            }}
          >
            <span>{formatDisplayTime()}</span>
            <span className="arrow">
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                style={{
                  transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
                  transition: 'transform 0.2s',
                }}
              >
                <path
                  d="M7 10l5 5 5-5"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                />
              </svg>
            </span>
          </div>
          {isExpanded && (
            <div className="time-selector">
              {availableTimes.length === 0 ? (
                <div className="no-times">Geen beschikbare tijden.</div>
              ) : (
                <div className="time-options">
                  {availableTimes.map((time) => (
                    <div
                      key={time.value}
                      className={`time-option ${
                        formData[field.id] === time.value ? 'selected' : ''
                      }`}
                      onClick={() => handleTimeSelect(time.value)}
                    >
                      {time.label}
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}
        </>
      )}
    </div>
  );
};

export default TimeSelector;


--- Utils/dateUtils.js ---
// src/Pages/NewReservation/Utils/dateUtils.js

import moment from 'moment-timezone';

export const isWeekInPast = (weekStartDate) => {
  const today = moment().tz('Europe/Brussels').startOf('day');
  const weekEndDate = weekStartDate.clone().add(6, 'days').endOf('day');
  return weekEndDate.isBefore(today);
};

export const isSameDay = (date1, date2) => date1.isSame(date2, 'day');


--- Utils/dates/blockDates.js ---
// src/Pages/NewReservation/Utils/dates/blockDates.js

import { DateTime } from 'luxon';

const getOrInitializeArray = (dict, key) => {
  if (!Array.isArray(dict[key])) {
    dict[key] = [];
  }
  return dict[key];
};

const initializeDictionaries = () => {
  window.dateDictionary = window.dateDictionary || {};
  window.shiftsPerDate = window.shiftsPerDate || {};
};

const processTimeblock = (block) => {
  if (!block.date) {
    return;
  }

  const dateString = DateTime.fromISO(block.date, { zone: 'Europe/Brussels' }).toISODate();

  // Check if date is in closedDates
  if (window.closedDates.has(dateString)) {
    return;
  }

  // Check for exceptional openings
  if (window.exceptionalOpenings[dateString]) {
    const exceptionalOpening = window.exceptionalOpenings[dateString];
    window.dateDictionary[dateString] = [
      {
        startTime: exceptionalOpening.startTime,
        endTime: exceptionalOpening.endTime,
      },
    ];
  } else {
    // Use the block's times
    if (!window.dateDictionary[dateString]) {
      window.dateDictionary[dateString] = [];
    }
    window.dateDictionary[dateString].push({
      startTime: block.startTime || null,
      endTime: block.endTime || null,
    });
  }

  // Process shifts
  if (block.shifts && Array.isArray(block.shifts) && block.shifts.length > 0) {
    const shiftsArray = getOrInitializeArray(window.shiftsPerDate, dateString);

    block.shifts.forEach((shift) => {
      const exists = shiftsArray.some(
        (existingShift) =>
          existingShift.name === shift.name && existingShift.startTime === shift.startTime
      );
      if (!exists) {
        shiftsArray.push({
          name: shift.name || '',
          startTime: shift.startTime || '',
          endTime: shift.endTime || null,
        });
      }
    });
  }
};

export const getBlockSettingsDates = (timeblocks) => {
  initializeDictionaries();
  const dates = [];

  timeblocks.forEach((block) => {
    processTimeblock(block);
    // Do not add date if not in dateDictionary (i.e., date was skipped)
    if (block.date) {
      const dateString = DateTime.fromISO(block.date, { zone: 'Europe/Brussels' }).toISODate();
      if (window.dateDictionary[dateString]) {
        dates.push(dateString);
      }
    }
  });

  return dates;
};


--- Utils/dates/schemeDates.js ---
// src/Pages/NewReservation/Utils/dates/schemeDates.js

import { DateTime } from 'luxon';

const getOrInitializeArray = (dict, key) => {
  if (!Array.isArray(dict[key])) {
    dict[key] = [];
  }
  return dict[key];
};

const initializeDictionaries = () => {
  window.dateDictionary = window.dateDictionary || {};
  window.shiftsPerDate = window.shiftsPerDate || {};
};

const isWithinPeriod = (currentDate, endDate) => {
  return currentDate <= endDate;
};

const processDaySetting = (dateString, daySetting) => {
  // Check if date is in closedDates
  if (window.closedDates.has(dateString)) {
    return;
  }

  // Check for exceptional openings
  if (window.exceptionalOpenings[dateString]) {
    const exceptionalOpening = window.exceptionalOpenings[dateString];
    window.dateDictionary[dateString] = [
      {
        startTime: exceptionalOpening.startTime,
        endTime: exceptionalOpening.endTime,
      },
    ];
  } else {
    // Use the daySetting's times
    if (!window.dateDictionary[dateString]) {
      window.dateDictionary[dateString] = [];
    }
    window.dateDictionary[dateString].push({
      startTime: daySetting.startTime || null,
      endTime: daySetting.endTime || null,
    });
  }

  // Process shifts
  if (
    daySetting.shiftsEnabled &&
    Array.isArray(daySetting.shifts) &&
    daySetting.shifts.length > 0
  ) {
    const shiftsArray = getOrInitializeArray(window.shiftsPerDate, dateString);

    daySetting.shifts.forEach((shift) => {
      const exists = shiftsArray.some(
        (existingShift) =>
          existingShift.name === shift.name && existingShift.startTime === shift.startTime
      );
      if (!exists) {
        shiftsArray.push({
          name: shift.name || '',
          startTime: shift.startTime || '',
          endTime: shift.endTime || null,
        });
      }
    });
  }
};

export const getSchemeSettingsDates = (timeblocks, maxDate) => {
  initializeDictionaries();
  const dates = [];
  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

  timeblocks.forEach((block) => {
    if (!block.schemeSettings) {
      return;
    }

    const { schemeSettings } = block;
    let currentDate = DateTime.now().setZone('Europe/Brussels').startOf('day');

    // Adjust endDate based on dagenInToekomst
    let endDate = maxDate;

    if (schemeSettings.period && schemeSettings.period.enabled) {
      const { startDate, endDate: periodEndDate } = schemeSettings.period;
      if (startDate && periodEndDate) {
        currentDate = DateTime.fromISO(startDate, { zone: 'Europe/Brussels' }).startOf('day');
        const schemeEndDate = DateTime.fromISO(periodEndDate, { zone: 'Europe/Brussels' }).endOf('day');
        // Use the minimum of schemeEndDate and maxDate
        endDate = schemeEndDate < maxDate ? schemeEndDate : maxDate;
      }
    }

    while (isWithinPeriod(currentDate, endDate)) {
      const dayOfWeek = currentDate.weekday % 7;
      const dayName = dayNames[dayOfWeek];
      const daySetting = schemeSettings[dayName];
      const dateString = currentDate.toISODate();
      if (daySetting && daySetting.enabled) {
        processDaySetting(dateString, daySetting);
        if (window.dateDictionary[dateString]) {
          dates.push(dateString);
        }
      }
      currentDate = currentDate.plus({ days: 1 });
    }
  });
  return dates;
};


--- Utils/exceptions.js ---
// Utils/exceptions.js

import { DateTime } from 'luxon';

export const collectExceptions = (timeblocks) => {
    // Initialize global exception containers
    window.closedDates = new Set();
    window.exceptionalOpenings = {};
    window.uitzonderlijkeCapaciteit = {}; // Initialize capaciteit exceptions

    timeblocks.forEach((block) => {
        if (!block.exceptionalDays) {
            return;
        }

        const { exceptionalDays } = block;

        // Process sluitingsperiode (closing periods)
        if (Array.isArray(exceptionalDays.sluitingsperiode)) {
            exceptionalDays.sluitingsperiode.forEach((period) => {
                if (period.enabled) {
                    const { startDate, endDate } = period;
                    if (startDate && endDate) {
                        let currentDate = DateTime.fromISO(startDate, { zone: "Europe/Brussels" }).startOf('day');
                        const endDateObj = DateTime.fromISO(endDate, { zone: "Europe/Brussels" }).startOf('day');
                        while (currentDate <= endDateObj) {
                            const dateString = currentDate.toISODate();
                            window.closedDates.add(dateString);
                            console.log(`[collectExceptions] Adding ${dateString} to closedDates due to sluitingsperiode.`);
                            currentDate = currentDate.plus({ days: 1 });
                        }
                    }
                }
            });
        }

        // Process uitzonderlijkeOpeningsuren (exceptional opening hours)
        if (Array.isArray(exceptionalDays.uitzonderlijkeOpeningsuren)) {
            exceptionalDays.uitzonderlijkeOpeningsuren.forEach((opening) => {
                if (opening.enabled) {
                    const { date, startTime, endTime } = opening;
                    if (date && startTime && endTime) {
                        window.exceptionalOpenings[date] = {
                            startTime,
                            endTime,
                        };
                        console.log(`[collectExceptions] Adding exceptional opening for ${date}: ${startTime} - ${endTime}`);
                    }
                }
            });
        }

        // Process uitzonderlijkeCapaciteit (exceptional capacity)
        if (Array.isArray(exceptionalDays.uitzonderlijkeCapaciteit)) {
            exceptionalDays.uitzonderlijkeCapaciteit.forEach((capacityEntry) => {
                if (capacityEntry.enabled) {
                    const { date, capacity } = capacityEntry;
                    if (date && capacity !== undefined && capacity !== null) {
                        // Convert capacity to a number if it's a string
                        const numericCapacity = Number(capacity);
                        if (!isNaN(numericCapacity)) {
                            window.uitzonderlijkeCapaciteit[date] = numericCapacity;
                            console.log(`[collectExceptions] Setting exceptional capacity for ${date}: ${numericCapacity}`);
                        } else {
                            console.warn(`[collectExceptions] Invalid capacity value for ${date}: ${capacity}`);
                        }
                    }
                }
            });
        }
    });
};


--- Utils/generateDates.js ---
// Utils/generateDates.js

import { DateTime } from 'luxon';
import { collectExceptions } from './exceptions';
import { getSchemeSettingsDates } from './dates/schemeDates';
import { getBlockSettingsDates } from './dates/blockDates';
import { generateAvailableTimesForDate } from './generateTimes'; // Ensure correct import path

const initializeDictionaries = () => {
    window.dateDictionary = window.dateDictionary || {};
    window.shiftsPerDate = window.shiftsPerDate || {};
};

export const generateAvailableDates = (guests, timeblocks = [], reservations = []) => {
    initializeDictionaries();
    collectExceptions(timeblocks);

    const dagenInToekomstRaw = window.generalSettings?.dagenInToekomst;
    let dagenInToekomst = 365;

    if (dagenInToekomstRaw) {
        if (typeof dagenInToekomstRaw === 'number') {
            dagenInToekomst = dagenInToekomstRaw;
        } else if (typeof dagenInToekomstRaw === 'string') {
            dagenInToekomst = parseInt(dagenInToekomstRaw, 10);
            if (isNaN(dagenInToekomst)) {
                dagenInToekomst = 365;
            }
        }
    }

    const today = DateTime.now().setZone("Europe/Brussels").startOf('day');
    const maxDate = today.plus({ days: dagenInToekomst - 1 }).endOf('day'); // Subtract 1 because we count today as day 1

    const blockDates = getBlockSettingsDates(timeblocks);
    const schemeDates = getSchemeSettingsDates(timeblocks, maxDate);
    const combinedDates = [...blockDates, ...schemeDates];

    const filteredDates = combinedDates.filter(dateStr => {
        const date = DateTime.fromISO(dateStr, { zone: "Europe/Brussels" }).startOf('day');
        return date >= today && date <= maxDate;
    });

    let uniqueDates = Array.from(new Set(filteredDates)).sort();

    // Initialize countingDictionary
    const countingDictionary = {};

    // Retrieve intervalReservatie and validate it
    const intervalReservatie = window.generalSettings?.intervalReservatie;
    let intervalMinutes = 30; // Default value

    if (
        typeof intervalReservatie === 'number' &&
        Number.isInteger(intervalReservatie) &&
        intervalReservatie > 0
    ) {
        intervalMinutes = intervalReservatie;
    } else {
        console.warn(
            `[generateAvailableDates] Invalid intervalReservatie value "${intervalReservatie}". Using default intervalMinutes = 30`
        );
    }

    // Retrieve duurReservatie and validate it
    const duurReservatieRaw = window.generalSettings?.duurReservatie;
    let duurReservatieMinutes = 120; // Default duration in minutes (2 hours)

    if (
        typeof duurReservatieRaw === 'number' &&
        Number.isInteger(duurReservatieRaw) &&
        duurReservatieRaw > 0
    ) {
        duurReservatieMinutes = duurReservatieRaw;
    } else {
        console.warn(
            `[generateAvailableDates] Invalid duurReservatie value "${duurReservatieRaw}". Using default duurReservatieMinutes = 120`
        );
    }

    // Retrieve uurOpVoorhand and validate it
    let uurOpVoorhand = 0; // Default value

    // Function to generate times for a given dateKey
    const generateAvailableTimesForDateKey = (guests, dateKey) => {
        const dateDictionary = window.dateDictionary;
        const shiftsPerDate = window.shiftsPerDate;
        const selectedDate = DateTime.fromISO(dateKey, { zone: "Europe/Brussels" });

        if (!dateDictionary[dateKey] || dateDictionary[dateKey].length === 0) {
            return [];
        }

        const shiftData =
            shiftsPerDate && Array.isArray(shiftsPerDate[dateKey]) ? shiftsPerDate[dateKey] : [];

        if (shiftData.length > 0) {
            const shiftButtons = shiftData.map((shift) => ({
                label: shift.name,
                value: shift.startTime,
            }));
            return shiftButtons.map(button => button.value);
        }

        const times = [];

        dateDictionary[dateKey].forEach(({ startTime, endTime }) => {

            let startDateTime = DateTime.fromFormat(startTime, 'HH:mm', { zone: "Europe/Brussels" }).set({
                year: selectedDate.year,
                month: selectedDate.month,
                day: selectedDate.day
            });

            const endDateTime = DateTime.fromFormat(endTime, 'HH:mm', { zone: "Europe/Brussels" }).set({
                year: selectedDate.year,
                month: selectedDate.month,
                day: selectedDate.day
            });

            while (startDateTime < endDateTime) {
                const timeString = startDateTime.toFormat('HH:mm');
                times.push(timeString);
                startDateTime = startDateTime.plus({ minutes: intervalMinutes });
            }
        });

        const uniqueTimes = [...new Set(times)].sort(
            (a, b) => DateTime.fromFormat(a, 'HH:mm') - DateTime.fromFormat(b, 'HH:mm')
        );

        return uniqueTimes;
    };

    // Generate countingDictionary with initial counts
    uniqueDates.forEach(dateKey => {
        const times = generateAvailableTimesForDateKey(guests, dateKey);
        countingDictionary[dateKey] = {};

        times.forEach(time => {
            countingDictionary[dateKey][time] = 0;
        });
    });

    // Process reservations to update counts
    reservations.forEach(reservation => {
        const reservationDate = reservation.date; // string in "YYYY-MM-DD" format
        const reservationTime = reservation.time; // string in "HH:mm"
        const numberOfGuests = reservation.guests;

        if (countingDictionary[reservationDate]) {
            const resStartDateTime = DateTime.fromISO(`${reservationDate}T${reservationTime}`, { zone: "Europe/Brussels" });

            // Use duurReservatieMinutes instead of fixed 2 hours
            const resEndDateTime = resStartDateTime.plus({ minutes: duurReservatieMinutes });

            // For each time period in countingDictionary[reservationDate]
            Object.keys(countingDictionary[reservationDate]).forEach(timePeriodStart => {
                const timePeriodStartDateTime = DateTime.fromISO(`${reservationDate}T${timePeriodStart}`, { zone: "Europe/Brussels" });
                const timePeriodEndDateTime = timePeriodStartDateTime.plus({ minutes: intervalMinutes });

                // Check if reservation interval collides with time period
                if (resStartDateTime < timePeriodEndDateTime && resEndDateTime > timePeriodStartDateTime) {
                    // There is a collision
                    countingDictionary[reservationDate][timePeriodStart] += numberOfGuests;
                }
            });
        }
    });

    // Print the countingDictionary
    console.log('[generateAvailableDates] Counting Dictionary:', countingDictionary);

    // Store countingDictionary in window for access in generateAvailableTimesForDate
    window.countingDictionary = countingDictionary;

    // Remove dates with no available time buttons
    const datesToRemove = [];
    uniqueDates.forEach(dateKey => {
        const selectedDate = DateTime.fromISO(dateKey, { zone: "Europe/Brussels" }).toJSDate();
        const availableTimeButtons = generateAvailableTimesForDate(guests, selectedDate);

        if (availableTimeButtons.length === 0) {
            datesToRemove.push(dateKey);
        }
    });

    // Filter out the dates to remove
    uniqueDates = uniqueDates.filter(dateKey => !datesToRemove.includes(dateKey));

    // Print the final uniqueDates
    console.log('[generateAvailableDates] Final Unique Dates:', uniqueDates);

    return uniqueDates;
};


--- Utils/generateTimes.js ---
// Utils/generateTimes.js

import { DateTime } from 'luxon';

const TARGET_DATE = '2024-12-03'; // The date we're focusing on

const formatDateKey = (date) => {
    const formattedDate = DateTime.fromJSDate(date).toISODate();
    return formattedDate;
};

export const generateAvailableTimesForDate = (guests, selectedDate) => {
    const dateDictionary = window.dateDictionary;
    const shiftsPerDate = window.shiftsPerDate;
    const dateKey = formatDateKey(selectedDate);
    const now = DateTime.now().setZone("Europe/Brussels");
    const selectedDateTime = DateTime.fromJSDate(selectedDate).setZone("Europe/Brussels");
    const isToday = selectedDateTime.hasSame(now, 'day');

    if (dateKey === TARGET_DATE) {
        console.log(`[generateAvailableTimesForDate] Generating available times for dateKey: ${dateKey}`);
    }

    // Retrieve and validate 'uurOpVoorhand' from generalSettings
    const uurOpVoorhandRaw = window.generalSettings?.uurOpVoorhand;
    let uurOpVoorhand = 4; // Default value

    if (typeof uurOpVoorhandRaw === 'number' && uurOpVoorhandRaw >= 0) {
        uurOpVoorhand = uurOpVoorhandRaw;
        if (dateKey === TARGET_DATE) {
            console.log(`[generateAvailableTimesForDate] 'uurOpVoorhand' set to: ${uurOpVoorhand} hours`);
        }
    } else {
        console.warn(
            `[generateAvailableTimesForDate] Invalid or missing 'uurOpVoorhand' value ("${uurOpVoorhandRaw}"). Using default: ${uurOpVoorhand} hours`
        );
    }

    let minAllowedTime;
    if (isToday) {
        minAllowedTime = now.plus({ hours: uurOpVoorhand });
        if (dateKey === TARGET_DATE) {
            console.log(`[generateAvailableTimesForDate] Today (${dateKey}) - minAllowedTime set to: ${minAllowedTime.toFormat('HH:mm')}`);
        }
    } else {
        minAllowedTime = selectedDateTime.startOf('day');
        if (dateKey === TARGET_DATE) {
            console.log(`[generateAvailableTimesForDate] Future date (${dateKey}) - minAllowedTime set to start of the day (${minAllowedTime.toFormat('HH:mm')})`);
        }
    }

    // Retrieve and validate 'intervalReservatie' from generalSettings
    const intervalReservatie = window.generalSettings?.intervalReservatie;
    let intervalMinutes = 30; // Default value

    if (
        typeof intervalReservatie === 'number' &&
        Number.isInteger(intervalReservatie) &&
        intervalReservatie > 0
    ) {
        intervalMinutes = intervalReservatie;
        if (dateKey === TARGET_DATE) {
            console.log(`[generateAvailableTimesForDate] 'intervalReservatie' set to: ${intervalMinutes} minutes`);
        }
    } else {
        console.warn(
            `[generateAvailableTimesForDate] Invalid or missing 'intervalReservatie' value ("${intervalReservatie}"). Using default: ${intervalMinutes} minutes`
        );
    }

    // Retrieve and validate 'duurReservatie' from generalSettings
    const duurReservatieRaw = window.generalSettings?.duurReservatie;
    let duurReservatieMinutes = 120; // Default duration in minutes (2 hours)

    if (
        typeof duurReservatieRaw === 'number' &&
        Number.isInteger(duurReservatieRaw) &&
        duurReservatieRaw > 0
    ) {
        duurReservatieMinutes = duurReservatieRaw;
        if (dateKey === TARGET_DATE) {
            console.log(`[generateAvailableTimesForDate] 'duurReservatie' set to: ${duurReservatieMinutes} minutes`);
        }
    } else {
        console.warn(
            `[generateAvailableTimesForDate] Invalid or missing 'duurReservatie' value ("${duurReservatieRaw}"). Using default: ${duurReservatieMinutes} minutes`
        );
    }

    if (!dateDictionary[dateKey] || dateDictionary[dateKey].length === 0) {
        if (dateKey === TARGET_DATE) {
            console.warn(`[generateAvailableTimesForDate] No dateDictionary entries found for dateKey: ${dateKey}`);
        }
        return [];
    }

    const shiftData =
        shiftsPerDate && Array.isArray(shiftsPerDate[dateKey]) ? shiftsPerDate[dateKey] : [];

    let timeButtons = [];

    if (shiftData.length > 0) {
        if (dateKey === TARGET_DATE) {
            console.log(`[generateAvailableTimesForDate] Found ${shiftData.length} shiftData entries for dateKey: ${dateKey}`);
        }
        timeButtons = shiftData.map((shift) => ({
            label: shift.name,
            value: shift.startTime,
        }));
        const availableTimes = timeButtons.map(button => button.value);
        if (dateKey === TARGET_DATE) {
            console.log(`[generateAvailableTimesForDate] Shift-based available times for ${dateKey}:`, availableTimes);
        }
    } else {
        const times = [];

        dateDictionary[dateKey].forEach(({ startTime, endTime }) => {
            let startDateTime = DateTime.fromFormat(startTime, 'HH:mm', { zone: "Europe/Brussels" }).set({
                year: selectedDate.getFullYear(),
                month: selectedDate.getMonth() + 1,
                day: selectedDate.getDate()
            });

            const endDateTime = DateTime.fromFormat(endTime, 'HH:mm', { zone: "Europe/Brussels" }).set({
                year: selectedDate.getFullYear(),
                month: selectedDate.getMonth() + 1,
                day: selectedDate.getDate()
            });

            if (dateKey === TARGET_DATE) {
                console.log(`[generateAvailableTimesForDate] Processing time block for ${dateKey}: ${startTime} - ${endTime}`);
            }

            while (startDateTime < endDateTime) {
                if (startDateTime >= minAllowedTime) {
                    const timeString = startDateTime.toFormat('HH:mm');
                    times.push(timeString);
                }
                startDateTime = startDateTime.plus({ minutes: intervalMinutes });
            }
        });

        const uniqueTimes = [...new Set(times)].sort(
            (a, b) => DateTime.fromFormat(a, 'HH:mm') - DateTime.fromFormat(b, 'HH:mm')
        );
        if (dateKey === TARGET_DATE) {
            console.log(`[generateAvailableTimesForDate] Generated unique available times for ${dateKey}:`, uniqueTimes);
        }

        timeButtons = uniqueTimes.map((time) => ({
            label: time,
            value: time,
        }));
    }

    // Determine capacityLimit: use uitzonderlijkeCapaciteit if defined, else use general zitplaatsen
    const uitzonderlijkeCapaciteit = window.uitzonderlijkeCapaciteit || {};
    const exceptionalCapacity = uitzonderlijkeCapaciteit[dateKey];
    const capacityLimit = (typeof exceptionalCapacity === 'number')
        ? exceptionalCapacity
        : (window.generalSettings?.zitplaatsen || 0);

    if (typeof capacityLimit !== 'number' || capacityLimit < 0) {
        console.warn(
            `[generateAvailableTimesForDate] Invalid capacityLimit value ("${capacityLimit}"). Defaulting to 0.`
        );
    }

    const finalCapacityLimit = (typeof capacityLimit === 'number' && capacityLimit >= 0)
        ? capacityLimit
        : 0;

    if (dateKey === TARGET_DATE) {
        console.log(`[generateAvailableTimesForDate] Capacity limit for ${dateKey}: ${finalCapacityLimit} guests`);
    }

    // Filter timeButtons based on countingDictionary and capacityLimit
    const countingDictionary = window.countingDictionary || {};

    if (countingDictionary[dateKey]) {
        if (dateKey === TARGET_DATE) {
            console.log(`[generateAvailableTimesForDate] Applying capacity constraints for ${dateKey}`);
        }

        // Define the checkConsecutiveTimes function
        const checkConsecutiveTimes = (startTime) => {
            const intervalsToCheck = [];
            let currentTime = DateTime.fromFormat(startTime, 'HH:mm', { zone: "Europe/Brussels" });
            const endTime = currentTime.plus({ minutes: duurReservatieMinutes });

            while (currentTime < endTime) {
                const timeString = currentTime.toFormat('HH:mm');
                intervalsToCheck.push(timeString);
                currentTime = currentTime.plus({ minutes: intervalMinutes });
            }

            for (const time of intervalsToCheck) {
                const guestsCount = countingDictionary[dateKey][time] || 0;
                const availableCapacity = finalCapacityLimit - guestsCount;

                if (dateKey === TARGET_DATE) {
                    console.log(`[checkConsecutiveTimes] Time: ${time}, GuestsCount: ${guestsCount}, AvailableCapacity: ${availableCapacity}`);
                }

                if (guests > availableCapacity) {
                    // Not enough capacity at this time interval
                    return false;
                }
            }

            // All intervals have sufficient capacity
            return true;
        };

        timeButtons = timeButtons.filter(button => {
            const time = button.value;

            // Use the checkConsecutiveTimes function
            const canAccommodate = checkConsecutiveTimes(time);

            if (dateKey === TARGET_DATE) {
                console.log(`[generateAvailableTimesForDate] Time: ${time}, Can Accommodate: ${canAccommodate}`);
            }

            return canAccommodate;
        });
    } else {
        if (dateKey === TARGET_DATE) {
            console.warn(`[generateAvailableTimesForDate] No countingDictionary entries found for dateKey: ${dateKey}. All times are available.`);
        }
    }

    if (dateKey === TARGET_DATE) {
        console.log(`[generateAvailableTimesForDate] Final available time buttons for ${dateKey}:`, timeButtons);
    }

    return timeButtons;
};


--- ValueSelector.js ---
// src/Pages/NewReservation/ValueSelector.jsx

import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import './css/valueSelector.css';

const ValueSelectorGuests = ({ setGuests, value, onChange }) => {
  const predefinedValues = [1, 2, 3, '4+'];
  const [selectedValue, setSelectedValue] = useState(value || '');
  const [showSlider, setShowSlider] = useState(false);

  const handlePredefinedValueClick = (val) => {
    if (val === '4+') {
      setShowSlider(true);
      setSelectedValue(4);
      setGuests(4);
      onChange({ target: { name: 'guests', value: 4 } });
    } else {
      setShowSlider(false);
      setSelectedValue(val);
      setGuests(val);
      onChange({ target: { name: 'guests', value: val } });
    }
  };

  const handleSliderChange = (e) => {
    const val = e.target.value;
    setSelectedValue(val);
    setGuests(val);
    onChange({ target: { name: 'guests', value: val } });
  };

  const handleInputChange = (e) => {
    const val = e.target.value;
    setSelectedValue(val);
    setGuests(val);
    onChange({ target: { name: 'guests', value: val } });
  };

  return (
    <div className="value-selector">
      <div className="predefined-values">
        {predefinedValues.map((val) => (
          <button
            key={val}
            type="button"
            className={`predefined-value-button ${
              selectedValue == val || (val === '4+' && showSlider) ? 'active' : ''
            }`}
            onClick={() => handlePredefinedValueClick(val)}
          >
            {val === '4+' ? '4+' : `${val} ${val === 1 ? 'p' : 'p'}`}
          </button>
        ))}
      </div>
      <AnimatePresence>
        {showSlider && (
          <motion.div
            className="slider-container"
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
          >
            <input
              type="range"
              min="4"
              max="15"
              step="1"
              value={selectedValue}
              onChange={handleSliderChange}
              className="slider"
            />
            <input
              type="number"
              name="guests"
              value={selectedValue}
              onChange={handleInputChange}
              className="value-input"
              min="4"
              max="100"
              step="1"
            />
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default ValueSelectorGuests;


--- index.js ---
// src/Pages/NewReservation/ReservationStepOne.jsx

import React, { useState, useEffect } from 'react';
import ValueSelectorGuests from './ValueSelector';
import DateSelector from './DateSelector';
import TimeSelector from './TimeSelector';

const ReservationStepOne = ({
  formData,
  errors,
  handleChange,
  handleStepOneSubmit,
  setFormData,
  timeblocks,
  loadingTimeblocks,
  timeblocksError,
}) => {
  const [guests, setGuests] = useState(1);
  
  const resetFormDataFields = (fieldsToReset) => {
    setFormData((prevFormData) => {
      const newFormData = { ...prevFormData };
      fieldsToReset.forEach((field) => {
        newFormData[field] = '';
      });
      return newFormData;
    });
  };

  useEffect(() => {
      resetFormDataFields(['date', 'time']);
  }, [guests]);



  if (timeblocksError) {
    return (
      <div>
        <a
          href="https://dashboard.reservaties.net/#/scheme"
          target="_blank"
          rel="noopener noreferrer"
          style={{ color: 'var(--color-blue)', textDecoration: 'underline' }}
        >
          Klik hier
        </a>{' '}
        om uw openingsuren in te stellen.
      </div>
    );
  }

  return (
    <form className="account-manage-form" onSubmit={handleStepOneSubmit} noValidate>
      <ValueSelectorGuests
        setGuests={setGuests}
        value={formData.guests}
        onChange={handleChange}
        error={errors.guests}
      />

      {formData.guests && (
        <DateSelector
          guests={formData.guests}
          formData={formData}
          handleChange={handleChange}
          resetFormDataFields={resetFormDataFields}
          timeblocks={timeblocks}
        />
      )}

      {formData.date && (
        <TimeSelector
          guests={formData.guests}
          formData={formData}
          handleChange={handleChange}
          field={{ id: 'time', label: 'Tijd' }}
          selectedDate={formData.date}
        />
      )}
    </form>
  );
};

export default ReservationStepOne;



Directory Structure for "/Users/thibaultvandesompele/Desktop/Mateza 4.0/Client/Dashboard/dashboard-general/src/Pages/NewReservation/StepOne":

├── Calendar.js
├── DateSelector.js
├── TimeSelector.js
├── Utils
│   ├── dateUtils.js
│   ├── dates
│   │   ├── blockDates.js
│   │   └── schemeDates.js
│   ├── exceptions.js
│   ├── generateDates.js
│   └── generateTimes.js
├── ValueSelector.js
├── css
│   ├── calendar.css
│   ├── timeSelector.css
│   └── valueSelector.css
└── index.js


List of Files:
Calendar.js
DateSelector.js
TimeSelector.js
Utils/dateUtils.js
Utils/dates/blockDates.js
Utils/dates/schemeDates.js
Utils/exceptions.js
Utils/generateDates.js
Utils/generateTimes.js
ValueSelector.js
index.js

