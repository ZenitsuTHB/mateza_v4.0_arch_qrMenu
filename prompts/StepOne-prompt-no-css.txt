File Contents:

--- Calendar.js ---
// src/Pages/NewReservation/Calendar.jsx

import React, { useState, useEffect, useRef } from 'react';
import moment from 'moment-timezone';
import 'moment/locale/nl';
import { isWeekInPast, isSameDay } from './Utils/dateUtils';
import './css/calendar.css';
import useApi from '../../../Hooks/useApi';

moment.locale('nl'); // Set moment to Dutch locale

const Calendar = ({
  availableDates,
  selectedDate,
  onSelectDate,
  autoExpand,
  onReservationsFetched, // New prop for callback
}) => {
  const [isExpanded, setIsExpanded] = useState(autoExpand || false);
  const [startDate, setStartDate] = useState(null);
  const [reservations, setReservations] = useState(null); // Local state for reservations
  const calendarRef = useRef(null);
  const api = useApi(); // Initialize useApi hook

  const maxDate = moment().tz('Europe/Amsterdam').add(1, 'year').endOf('day');

  useEffect(() => {
    if (autoExpand) {
      setIsExpanded(true);
    }
  }, [autoExpand]);

  useEffect(() => {
    const today = moment().tz('Europe/Amsterdam').startOf('day');
    let firstWeekStart = today.clone().startOf('isoWeek');
    while (isWeekInPast(firstWeekStart)) {
      firstWeekStart.add(1, 'week');
    }
    setStartDate(firstWeekStart);
  }, []);

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (
        calendarRef.current &&
        !calendarRef.current.contains(event.target)
      ) {
        setIsExpanded(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  useEffect(() => {
    const fetchAndHandleReservations = async () => {
      if (startDate) {
        const beginDate = startDate.format('YYYY-MM-DD');
        const endDate = startDate.clone().add(13, 'days').format('YYYY-MM-DD');
        const restaurantId = localStorage.getItem('username');
        const endpoint = `${window.baseDomain}api/slots/${restaurantId}/${beginDate}/${endDate}`;

        try {
          const data = await api.get(endpoint, { noCache: true });
          setReservations(data); // Update local state with fetched reservations
          console.log('Fetched reservations:', data);

          if (onReservationsFetched && typeof onReservationsFetched === 'function') {
            onReservationsFetched(data); // Invoke callback with fetched data
          }
        } catch (error) {
          console.error('Error fetching reservations:', error);
        }
      }
    };

    fetchAndHandleReservations();
  }, [startDate, api, onReservationsFetched]);

  const generateCalendarDays = (startDate) => {
    const days = [];
    const today = moment().tz('Europe/Amsterdam').startOf('day');
    const twoWeeksFromStart = startDate.clone().add(13, 'days');

    let date = startDate.clone();
    while (date.isSameOrBefore(twoWeeksFromStart, 'day')) {
      const formattedDate = date.format('YYYY-MM-DD');
      const isAvailable = availableDates.includes(formattedDate);

      days.push({
        date: date.clone(),
        isPast: date.isBefore(today, 'day'),
        isFuture: date.isAfter(maxDate, 'day'),
        isAvailable: isAvailable,
      });

      date.add(1, 'day');
    }

    return days;
  };

  const handleDateClick = (day) => {
    if (day.isAvailable && !day.isPast && !day.isFuture) {
      const formattedDate = day.date.format('YYYY-MM-DD');
      onSelectDate(formattedDate); // Notify parent
      setIsExpanded(false);
    } else {
      console.log('Date is not available for selection.');
    }
  };

  const handlePrevWeek = () => {
    const newStartDate = startDate.clone().subtract(1, 'week');
    if (isWeekInPast(newStartDate)) {
      console.log('Cannot go to previous week. It is in the past.');
      return;
    }
    setStartDate(newStartDate);
  };

  const handleNextWeek = () => {
    const newStartDate = startDate.clone().add(1, 'week');
    setStartDate(newStartDate);
  };

  const formatDisplayDate = () => {
    if (!selectedDate) {
      return 'Selecteer een datum'; // "Select a date" in Dutch
    }

    const selectedMoment = moment(selectedDate, 'YYYY-MM-DD')
      .tz('Europe/Amsterdam')
      .startOf('day');
    const today = moment().tz('Europe/Amsterdam').startOf('day');
    const tomorrow = moment().tz('Europe/Amsterdam').add(1, 'day').startOf('day');

    if (selectedMoment.isSame(today, 'day')) {
      return 'Vandaag'; // "Today" in Dutch
    } else if (selectedMoment.isSame(tomorrow, 'day')) {
      return 'Morgen'; // "Tomorrow" in Dutch
    } else {
      // Format: e.g., "Maandag 1 Januari 2023"
      return selectedMoment.format('dddd D MMMM YYYY');
    }
  };

  const days = startDate ? generateCalendarDays(startDate) : [];

  return (
    <div className="calendar-container" ref={calendarRef}>
      <div
        className="calendar-display"
        onClick={() => {
          setIsExpanded(!isExpanded);
        }}
      >
        <span>{formatDisplayDate()}</span>
        <span className="arrow">
          <svg
            width="12"
            height="12"
            viewBox="0 0 24 24"
            style={{
              transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
              transition: 'transform 0.2s',
            }}
          >
            <path
              d="M7 10l5 5 5-5"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
            />
          </svg>
        </span>
      </div>
      {isExpanded && startDate && (
        <div className="calendar">
          <div className="calendar-header">
            <button type="button" onClick={handlePrevWeek}>
              &lt;
            </button>
            <span>
              {startDate.format('DD MMM')} -{' '}
              {startDate.clone().add(13, 'days').format('DD MMM YYYY')}
            </span>
            <button type="button" onClick={handleNextWeek}>
              &gt;
            </button>
          </div>
          <div className="calendar-weeks-wrapper">
            <table className="calendar-table">
              <thead>
                <tr>
                  {['Ma', 'Di', 'Wo', 'Do', 'Vr', 'Za', 'Zo'].map((day) => (
                    <th key={day}>{day}</th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {Array.from({ length: 2 }).map((_, weekIndex) => (
                  <tr key={weekIndex}>
                    {days
                      .slice(weekIndex * 7, weekIndex * 7 + 7)
                      .map((dayObj, index) => {
                        const isSelected =
                          selectedDate &&
                          isSameDay(
                            dayObj.date,
                            moment(selectedDate, 'YYYY-MM-DD').tz('Europe/Amsterdam')
                          );
                        const classNames = [];
                        if (dayObj.isPast) {
                          classNames.push('gray-out');
                        } else if (dayObj.isAvailable) {
                          classNames.push('available');
                        } else {
                          classNames.push('unavailable');
                        }
                        if (isSelected) {
                          classNames.push('selected');
                        }

                        return (
                          <td
                            key={index}
                            className={classNames.join(' ')}
                            onClick={() => handleDateClick(dayObj)}
                            style={{
                              '--animation-order': index + weekIndex * 7,
                            }}
                          >
                            <div className="day-square">
                              {dayObj.date.date()}
                            </div>
                          </td>
                        );
                      })}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}
    </div>
  );
};

export default Calendar;


--- DateSelector.js ---
// src/Pages/NewReservation/DateSelector.jsx

import React, { useEffect, useState, useCallback } from 'react';
import Calendar from './Calendar';
import { generateAvailableDates } from './Utils/generateDates';
import moment from 'moment';

const DateSelector = ({
  formData,
  handleChange,
  resetFormDataFields,
  timeblocks,
}) => {
  const [availableDates, setAvailableDates] = useState([]);
  const [reservations, setReservations] = useState([]); // New state for reservations

  useEffect(() => {
    if (Array.isArray(timeblocks)) {
      const dates = generateAvailableDates(timeblocks, reservations);
      setAvailableDates(dates);
    } else {
      console.error('timeblocks is undefined or not an array:', timeblocks);
      setAvailableDates([]);
    }
  }, [timeblocks, reservations]);

  const handleDateSelect = (date) => {
    const formattedDate = moment(date).format('YYYY-MM-DD');
    console.log('Selected date:', formattedDate);
    handleChange({
      target: { name: 'date', value: formattedDate },
    });
    resetFormDataFields(['time']);
  };

  // Memoize the callback to prevent unnecessary re-renders
  const handleReservationsFetched = useCallback((data) => {
    setReservations(data); // Update the reservations state
  }, []);

  return (
    <div className="form-group date-selector-container">
      <label htmlFor="date" className="default-text-color">
        Datum<span className="required">*</span>
      </label>
      <Calendar
        availableDates={availableDates}
        selectedDate={formData.date || null}
        onSelectDate={handleDateSelect}
        autoExpand={false}
        onReservationsFetched={handleReservationsFetched} // Pass the handler as prop
      />
    </div>
  );
};

export default DateSelector;


--- Hooks/useFetchRestaurantData.js ---
// src/Hooks/useFetchRestaurantData.js

import { useState, useEffect } from 'react';
import useApi from '../../../../Hooks/useApi';

const useFetchRestaurantData = () => {
  const [restaurantData, setRestaurantData] = useState(null);
  const api = useApi();


  useEffect(() => {
    const fetchRestaurantData = async () => {
      try {
        const endpoint = `${window.baseDomain}api/auth-restaurant/`;
        const response = await api.get(endpoint);


        if (response) {
          setRestaurantData(response);
        }
      } catch (error) {
        console.error('Error fetching restaurant data:', error);
        const errorCode = error.response?.status || 'unknown';
      }
    };

    fetchRestaurantData();
  }, [api]);

  return restaurantData;
};

export default useFetchRestaurantData;


--- TimeSelector.js ---
// src/Pages/NewReservation/TimeSelector.jsx

import React, { useState, useEffect, useRef } from 'react';
import { generateAvailableTimesForDate } from './Utils/generateTimes';
import './css/timeSelector.css';

const TimeSelector = ({
  formData,
  handleChange,
  field,
  selectedDate,
  expanded,
  setCurrentExpandedField,
}) => {
  const [isExpanded, setIsExpanded] = useState(expanded || false);
  const [availableTimes, setAvailableTimes] = useState([]);
  const timeSelectorRef = useRef(null);

  useEffect(() => {
    if (selectedDate) {
      const times = generateAvailableTimesForDate(new Date(selectedDate));
      setAvailableTimes(times);
    } else {
      setAvailableTimes([]);
    }
  }, [selectedDate]);

  const handleTimeSelect = (timeValue) => {
    handleChange({
      target: { name: field.id, value: timeValue },
    });
    setIsExpanded(false);
    if (setCurrentExpandedField) {
      setCurrentExpandedField(null);
    }
  };

  const formatDisplayTime = () => {
    if (formData[field.id]) {
      const selected = availableTimes.find((time) => time.value === formData[field.id]);
      return selected ? selected.label : 'Selecteer een tijd';
    }
    return 'Selecteer een tijd';
  };

  if (!field) {
    return null;
  }

  return (
    <div className="form-group time-selector-container" ref={timeSelectorRef}>
      <label className="default-text-color" htmlFor={field.id}>
        {field.label}
        <span className="required">*</span>
      </label>

      {!selectedDate ? (
        <p className="info-text">Selecteer eerst een datum.</p>
      ) : (
        <>
          <div
            className="time-display"
            onClick={() => {
              setIsExpanded(!isExpanded);
              if (!isExpanded && setCurrentExpandedField) {
                setCurrentExpandedField('time');
              }
            }}
          >
            <span>{formatDisplayTime()}</span>
            <span className="arrow">
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                style={{
                  transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)',
                  transition: 'transform 0.2s',
                }}
              >
                <path
                  d="M7 10l5 5 5-5"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                />
              </svg>
            </span>
          </div>
          {isExpanded && (
            <div className="time-selector">
              {availableTimes.length === 0 ? (
                <div className="no-times">Geen beschikbare tijden.</div>
              ) : (
                <div className="time-options">
                  {availableTimes.map((time) => (
                    <div
                      key={time.value}
                      className={`time-option ${
                        formData[field.id] === time.value ? 'selected' : ''
                      }`}
                      onClick={() => handleTimeSelect(time.value)}
                    >
                      {time.label}
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}
        </>
      )}
    </div>
  );
};

export default TimeSelector;


--- Utils/dateUtils.js ---
// src/Pages/NewReservation/Utils/dateUtils.js

import moment from 'moment-timezone';

export const isWeekInPast = (weekStartDate) => {
  const today = moment().tz('Europe/Brussels').startOf('day');
  const weekEndDate = weekStartDate.clone().add(6, 'days').endOf('day');
  return weekEndDate.isBefore(today);
};

export const isSameDay = (date1, date2) => date1.isSame(date2, 'day');


--- Utils/dates/blockDates.js ---
// src/Pages/NewReservation/Utils/dates/blockDates.js

import { DateTime } from 'luxon';

const getOrInitializeArray = (dict, key) => {
  if (!Array.isArray(dict[key])) {
    dict[key] = [];
  }
  return dict[key];
};

const initializeDictionaries = () => {
  window.dateDictionary = window.dateDictionary || {};
  window.shiftsPerDate = window.shiftsPerDate || {};
};

const processTimeblock = (block) => {
  if (!block.date) {
    return;
  }

  const dateString = DateTime.fromISO(block.date, { zone: 'Europe/Brussels' }).toISODate();

  // Check if date is in closedDates
  if (window.closedDates.has(dateString)) {
    return;
  }

  // Check for exceptional openings
  if (window.exceptionalOpenings[dateString]) {
    const exceptionalOpening = window.exceptionalOpenings[dateString];
    window.dateDictionary[dateString] = [
      {
        startTime: exceptionalOpening.startTime,
        endTime: exceptionalOpening.endTime,
      },
    ];
  } else {
    // Use the block's times
    if (!window.dateDictionary[dateString]) {
      window.dateDictionary[dateString] = [];
    }
    window.dateDictionary[dateString].push({
      startTime: block.startTime || null,
      endTime: block.endTime || null,
    });
  }

  // Process shifts
  if (block.shifts && Array.isArray(block.shifts) && block.shifts.length > 0) {
    const shiftsArray = getOrInitializeArray(window.shiftsPerDate, dateString);

    block.shifts.forEach((shift) => {
      const exists = shiftsArray.some(
        (existingShift) =>
          existingShift.name === shift.name && existingShift.startTime === shift.startTime
      );
      if (!exists) {
        shiftsArray.push({
          name: shift.name || '',
          startTime: shift.startTime || '',
          endTime: shift.endTime || null,
        });
      }
    });
  }
};

export const getBlockSettingsDates = (timeblocks) => {
  initializeDictionaries();
  const dates = [];

  timeblocks.forEach((block) => {
    processTimeblock(block);
    // Do not add date if not in dateDictionary (i.e., date was skipped)
    if (block.date) {
      const dateString = DateTime.fromISO(block.date, { zone: 'Europe/Brussels' }).toISODate();
      if (window.dateDictionary[dateString]) {
        dates.push(dateString);
      }
    }
  });

  return dates;
};


--- Utils/dates/schemeDates.js ---
// src/Pages/NewReservation/Utils/dates/schemeDates.js

import { DateTime } from 'luxon';

const getOrInitializeArray = (dict, key) => {
  if (!Array.isArray(dict[key])) {
    dict[key] = [];
  }
  return dict[key];
};

const initializeDictionaries = () => {
  window.dateDictionary = window.dateDictionary || {};
  window.shiftsPerDate = window.shiftsPerDate || {};
};

const isWithinPeriod = (currentDate, endDate) => {
  return currentDate <= endDate;
};

const processDaySetting = (dateString, daySetting) => {
  // Check if date is in closedDates
  if (window.closedDates.has(dateString)) {
    return;
  }

  // Check for exceptional openings
  if (window.exceptionalOpenings[dateString]) {
    const exceptionalOpening = window.exceptionalOpenings[dateString];
    window.dateDictionary[dateString] = [
      {
        startTime: exceptionalOpening.startTime,
        endTime: exceptionalOpening.endTime,
      },
    ];
  } else {
    // Use the daySetting's times
    if (!window.dateDictionary[dateString]) {
      window.dateDictionary[dateString] = [];
    }
    window.dateDictionary[dateString].push({
      startTime: daySetting.startTime || null,
      endTime: daySetting.endTime || null,
    });
  }

  // Process shifts
  if (
    daySetting.shiftsEnabled &&
    Array.isArray(daySetting.shifts) &&
    daySetting.shifts.length > 0
  ) {
    const shiftsArray = getOrInitializeArray(window.shiftsPerDate, dateString);

    daySetting.shifts.forEach((shift) => {
      const exists = shiftsArray.some(
        (existingShift) =>
          existingShift.name === shift.name && existingShift.startTime === shift.startTime
      );
      if (!exists) {
        shiftsArray.push({
          name: shift.name || '',
          startTime: shift.startTime || '',
          endTime: shift.endTime || null,
        });
      }
    });
  }
};

export const getSchemeSettingsDates = (timeblocks, maxDate) => {
  initializeDictionaries();
  const dates = [];
  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

  timeblocks.forEach((block) => {
    if (!block.schemeSettings) {
      return;
    }

    const { schemeSettings } = block;
    let currentDate = DateTime.now().setZone('Europe/Brussels').startOf('day');

    // Adjust endDate based on dagenInToekomst
    let endDate = maxDate;

    if (schemeSettings.period && schemeSettings.period.enabled) {
      const { startDate, endDate: periodEndDate } = schemeSettings.period;
      if (startDate && periodEndDate) {
        currentDate = DateTime.fromISO(startDate, { zone: 'Europe/Brussels' }).startOf('day');
        const schemeEndDate = DateTime.fromISO(periodEndDate, { zone: 'Europe/Brussels' }).endOf('day');
        // Use the minimum of schemeEndDate and maxDate
        endDate = schemeEndDate < maxDate ? schemeEndDate : maxDate;
      }
    }

    while (isWithinPeriod(currentDate, endDate)) {
      const dayOfWeek = currentDate.weekday % 7;
      const dayName = dayNames[dayOfWeek];
      const daySetting = schemeSettings[dayName];
      const dateString = currentDate.toISODate();
      if (daySetting && daySetting.enabled) {
        processDaySetting(dateString, daySetting);
        if (window.dateDictionary[dateString]) {
          dates.push(dateString);
        }
      }
      currentDate = currentDate.plus({ days: 1 });
    }
  });
  return dates;
};


--- Utils/exceptions.js ---
// src/Pages/NewReservation/Utils/exceptions.js

import { DateTime } from 'luxon';

export const collectExceptions = (timeblocks) => {
  window.closedDates = new Set();
  window.exceptionalOpenings = {};

  timeblocks.forEach((block) => {
    if (!block.exceptionalDays) {
      return;
    }

    const { exceptionalDays } = block;

    // Process sluitingsperiode (closing periods)
    if (Array.isArray(exceptionalDays.sluitingsperiode)) {
      exceptionalDays.sluitingsperiode.forEach((period) => {
        if (period.enabled) {
          const { startDate, endDate } = period;
          if (startDate && endDate) {
            let currentDate = DateTime.fromISO(startDate, { zone: 'Europe/Brussels' }).startOf('day');
            const endDateObj = DateTime.fromISO(endDate, { zone: 'Europe/Brussels' }).startOf('day');
            while (currentDate <= endDateObj) {
              const dateString = currentDate.toISODate();
              window.closedDates.add(dateString);
              currentDate = currentDate.plus({ days: 1 });
            }
          }
        }
      });
    }

    // Process sluitingsdag (closing days)
    if (Array.isArray(exceptionalDays.sluitingsdag)) {
      exceptionalDays.sluitingsdag.forEach((day) => {
        if (day.enabled) {
          const { date } = day;
          if (date) {
            window.closedDates.add(date);
          }
        }
      });
    }

    // Process uitzonderlijkeOpeningsuren (exceptional opening hours)
    if (Array.isArray(exceptionalDays.uitzonderlijkeOpeningsuren)) {
      exceptionalDays.uitzonderlijkeOpeningsuren.forEach((opening) => {
        if (opening.enabled) {
          const { date, startTime, endTime } = opening;
          if (date && startTime && endTime) {
            window.exceptionalOpenings[date] = {
              startTime,
              endTime,
            };
          }
        }
      });
    }
  });
};


--- Utils/generateDates.js ---
// src/Pages/NewReservation/Utils/generateDates.js

import { DateTime } from 'luxon';
import { collectExceptions } from './exceptions';
import { getSchemeSettingsDates } from './dates/schemeDates';
import { getBlockSettingsDates } from './dates/blockDates';
import { generateAvailableTimesForDate } from './generateTimes';

const initializeDictionaries = () => {
  window.dateDictionary = window.dateDictionary || {};
  window.shiftsPerDate = window.shiftsPerDate || {};
};

export const generateAvailableDates = (timeblocks = [], reservations = []) => {
  initializeDictionaries();
  collectExceptions(timeblocks);

  const dagenInToekomstRaw = window.generalSettings?.dagenInToekomst;
  let dagenInToekomst = 365;

  if (dagenInToekomstRaw) {
    if (typeof dagenInToekomstRaw === 'number') {
      dagenInToekomst = dagenInToekomstRaw;
    } else if (typeof dagenInToekomstRaw === 'string') {
      dagenInToekomst = parseInt(dagenInToekomstRaw, 10);
      if (isNaN(dagenInToekomst)) {
        dagenInToekomst = 365;
      }
    }
  }

  const today = DateTime.now().setZone('Europe/Brussels').startOf('day');
  const maxDate = today.plus({ days: dagenInToekomst - 1 }).endOf('day');

  const blockDates = getBlockSettingsDates(timeblocks);
  const schemeDates = getSchemeSettingsDates(timeblocks, maxDate);
  const combinedDates = [...blockDates, ...schemeDates];

  const filteredDates = combinedDates.filter((dateStr) => {
    const date = DateTime.fromISO(dateStr, { zone: 'Europe/Brussels' }).startOf('day');
    return date >= today && date <= maxDate;
  });

  let uniqueDates = Array.from(new Set(filteredDates)).sort();

  // Initialize countingDictionary
  const countingDictionary = {};

  // Retrieve intervalReservatie and validate it
  const intervalReservatie = window.generalSettings?.intervalReservatie;
  let intervalMinutes = 30; // Default value

  if (
    typeof intervalReservatie === 'number' &&
    Number.isInteger(intervalReservatie) &&
    intervalReservatie > 0
  ) {
    intervalMinutes = intervalReservatie;
  } else {
    console.warn(
      `[generateAvailableDates] Invalid intervalReservatie value "${intervalReservatie}". Using default intervalMinutes = 30`
    );
  }

  // Retrieve duurReservatie and validate it
  const duurReservatieRaw = window.generalSettings?.duurReservatie;
  let duurReservatieMinutes = 120; // Default duration in minutes (2 hours)

  if (
    typeof duurReservatieRaw === 'number' &&
    Number.isInteger(duurReservatieRaw) &&
    duurReservatieRaw > 0
  ) {
    duurReservatieMinutes = duurReservatieRaw;
  } else {
    console.warn(
      `[generateAvailableDates] Invalid duurReservatie value "${duurReservatieRaw}". Using default duurReservatieMinutes = 120`
    );
  }

  // Function to generate times for a given dateKey
  const generateAvailableTimesForDateKey = (dateKey) => {
    const dateDictionary = window.dateDictionary;
    const shiftsPerDate = window.shiftsPerDate;

    if (!dateDictionary[dateKey] || dateDictionary[dateKey].length === 0) {
      return [];
    }

    const shiftData =
      shiftsPerDate && Array.isArray(shiftsPerDate[dateKey]) ? shiftsPerDate[dateKey] : [];

    if (shiftData.length > 0) {
      const shiftButtons = shiftData.map((shift) => ({
        label: shift.name,
        value: shift.startTime,
      }));
      return shiftButtons.map((button) => button.value);
    }

    const times = [];
    const selectedDate = DateTime.fromISO(dateKey, { zone: 'Europe/Brussels' }).toJSDate();

    dateDictionary[dateKey].forEach(({ startTime, endTime }) => {
      let startDateTime = DateTime.fromFormat(startTime, 'HH:mm', { zone: 'Europe/Brussels' }).set({
        year: selectedDate.getFullYear(),
        month: selectedDate.getMonth() + 1,
        day: selectedDate.getDate(),
      });

      const endDateTime = DateTime.fromFormat(endTime, 'HH:mm', { zone: 'Europe/Brussels' }).set({
        year: selectedDate.getFullYear(),
        month: selectedDate.getMonth() + 1,
        day: selectedDate.getDate(),
      });

      while (startDateTime < endDateTime) {
        const timeString = startDateTime.toFormat('HH:mm');
        times.push(timeString);
        startDateTime = startDateTime.plus({ minutes: intervalMinutes });
      }
    });

    const uniqueTimes = [...new Set(times)].sort(
      (a, b) => DateTime.fromFormat(a, 'HH:mm') - DateTime.fromFormat(b, 'HH:mm')
    );

    return uniqueTimes;
  };

  // Generate countingDictionary with initial counts
  uniqueDates.forEach((dateKey) => {
    const times = generateAvailableTimesForDateKey(dateKey);
    countingDictionary[dateKey] = {};

    times.forEach((time) => {
      countingDictionary[dateKey][time] = 0;
    });
  });

  // Process reservations to update counts
  reservations.forEach((reservation) => {
    const reservationDate = reservation.date; // string in "YYYY-MM-DD" format
    const reservationTime = reservation.time; // string in "HH:mm"
    const numberOfGuests = reservation.guests;

    if (countingDictionary[reservationDate]) {
      const resStartDateTime = DateTime.fromISO(
        `${reservationDate}T${reservationTime}`,
        { zone: 'Europe/Brussels' }
      );

      // Use duurReservatieMinutes instead of fixed 2 hours
      const resEndDateTime = resStartDateTime.plus({ minutes: duurReservatieMinutes });

      // For each time period in countingDictionary[reservationDate]
      Object.keys(countingDictionary[reservationDate]).forEach((timePeriodStart) => {
        const timePeriodStartDateTime = DateTime.fromISO(
          `${reservationDate}T${timePeriodStart}`,
          { zone: 'Europe/Brussels' }
        );
        const timePeriodEndDateTime = timePeriodStartDateTime.plus({ minutes: intervalMinutes });

        // Check if reservation interval collides with time period
        if (resStartDateTime < timePeriodEndDateTime && resEndDateTime > timePeriodStartDateTime) {
          // There is a collision
          countingDictionary[reservationDate][timePeriodStart] += numberOfGuests;
        }
      });
    }
  });

  // Store countingDictionary in window for access in generateAvailableTimesForDate
  window.countingDictionary = countingDictionary;

  // Remove dates with no available time buttons
  const datesToRemove = [];
  uniqueDates.forEach((dateKey) => {
    const selectedDate = DateTime.fromISO(dateKey, { zone: 'Europe/Brussels' }).toJSDate();
    const availableTimeButtons = generateAvailableTimesForDate(selectedDate);

    if (availableTimeButtons.length === 0) {
      datesToRemove.push(dateKey);
    }
  });

  // Filter out the dates to remove
  uniqueDates = uniqueDates.filter((dateKey) => !datesToRemove.includes(dateKey));

  return uniqueDates;
};


--- Utils/generateTimes.js ---
// src/Pages/NewReservation/Utils/generateTimes.js

import { DateTime } from 'luxon';

const formatDateKey = (date) => {
  const formattedDate = DateTime.fromJSDate(date).toISODate();
  return formattedDate;
};

export const generateAvailableTimesForDate = (selectedDate) => {
  const dateDictionary = window.dateDictionary;
  const shiftsPerDate = window.shiftsPerDate;
  const dateKey = formatDateKey(selectedDate);
  const now = DateTime.now().setZone('Europe/Brussels');

  // Retrieve intervalReservatie and validate it
  const intervalReservatie = window.generalSettings?.intervalReservatie;
  let intervalMinutes = 30; // Default value

  if (
    typeof intervalReservatie === 'number' &&
    Number.isInteger(intervalReservatie) &&
    intervalReservatie > 0
  ) {
    intervalMinutes = intervalReservatie;
  } else {
    console.warn(
      `[generateAvailableTimesForDate] Invalid intervalReservatie value "${intervalReservatie}". Using default intervalMinutes = 30`
    );
  }

  if (!dateDictionary[dateKey] || dateDictionary[dateKey].length === 0) {
    return [];
  }

  const shiftData =
    shiftsPerDate && Array.isArray(shiftsPerDate[dateKey]) ? shiftsPerDate[dateKey] : [];

  let timeButtons = [];

  if (shiftData.length > 0) {
    timeButtons = shiftData.map((shift) => ({
      label: shift.name,
      value: shift.startTime,
    }));
  } else {
    const times = [];

    dateDictionary[dateKey].forEach(({ startTime, endTime }) => {
      let startDateTime = DateTime.fromFormat(startTime, 'HH:mm', { zone: 'Europe/Brussels' }).set({
        year: selectedDate.getFullYear(),
        month: selectedDate.getMonth() + 1,
        day: selectedDate.getDate(),
      });

      const endDateTime = DateTime.fromFormat(endTime, 'HH:mm', { zone: 'Europe/Brussels' }).set({
        year: selectedDate.getFullYear(),
        month: selectedDate.getMonth() + 1,
        day: selectedDate.getDate(),
      });

      while (startDateTime < endDateTime) {
        if (startDateTime > now) {
          const timeString = startDateTime.toFormat('HH:mm');
          times.push(timeString);
        }
        startDateTime = startDateTime.plus({ minutes: intervalMinutes });
      }
    });

    const uniqueTimes = [...new Set(times)].sort(
      (a, b) => DateTime.fromFormat(a, 'HH:mm') - DateTime.fromFormat(b, 'HH:mm')
    );

    timeButtons = uniqueTimes.map((time) => ({
      label: time,
      value: time,
    }));
  }

  // Filter timeButtons based on countingDictionary
  const capacityLimit = 3;
  const countingDictionary = window.countingDictionary || {};

  if (countingDictionary[dateKey]) {
    timeButtons = timeButtons.filter((button) => {
      const time = button.value;
      const guestsCount = countingDictionary[dateKey][time] || 0;
      return guestsCount < capacityLimit;
    });
  }

  return timeButtons;
};


--- ValueSelector.js ---
// src/Pages/NewReservation/ValueSelector.jsx

import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import './css/valueSelector.css';

const ValueSelectorGuests = ({ value, onChange }) => {
  const predefinedValues = [1, 2, 3, '4+ Gasten'];
  const [selectedValue, setSelectedValue] = useState(value || '');
  const [showSlider, setShowSlider] = useState(false);

  const handlePredefinedValueClick = (val) => {
    if (val === '4+ Gasten') {
      setShowSlider(true);
      setSelectedValue(4);
      onChange({ target: { name: 'numberOfGuests', value: 4 } });
    } else {
      setShowSlider(false);
      setSelectedValue(val);
      onChange({ target: { name: 'numberOfGuests', value: val } });
    }
  };

  const handleSliderChange = (e) => {
    const val = e.target.value;
    setSelectedValue(val);
    onChange({ target: { name: 'numberOfGuests', value: val } });
  };

  const handleInputChange = (e) => {
    const val = e.target.value;
    setSelectedValue(val);
    onChange({ target: { name: 'numberOfGuests', value: val } });
  };

  return (
    <div className="value-selector">
      <div className="predefined-values">
        {predefinedValues.map((val) => (
          <button
            key={val}
            type="button"
            className={`predefined-value-button ${
              selectedValue == val || (val === '4+ Gasten' && showSlider) ? 'active' : ''
            }`}
            onClick={() => handlePredefinedValueClick(val)}
          >
            {val === '4+ Gasten' ? '4+ Gasten' : `${val} ${val === 1 ? 'Gast' : 'Gasten'}`}
          </button>
        ))}
      </div>
      <AnimatePresence>
        {showSlider && (
          <motion.div
            className="slider-container"
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
          >
            <input
              type="range"
              min="4"
              max="15"
              step="1"
              value={selectedValue}
              onChange={handleSliderChange}
              className="slider"
            />
            <input
              type="number"
              name="numberOfGuests"
              value={selectedValue}
              onChange={handleInputChange}
              className="value-input"
              min="4"
              max="100"
              step="1"
            />
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default ValueSelectorGuests;


--- index.js ---
// src/Pages/NewReservation/ReservationStepOne.jsx

import React, { useState, useEffect } from 'react';
import ValueSelectorGuests from './ValueSelector';
import DateSelector from './DateSelector';
import TimeSelector from './TimeSelector';
import useApi from '../../../Hooks/useApi';

const ReservationStepOne = ({
  formData,
  errors,
  handleChange,
  handleStepOneSubmit,
  setFormData,
}) => {
  const api = useApi();

  // State for timeblocks
  const [timeblocks, setTimeblocks] = useState([]);
  const [loadingTimeblocks, setLoadingTimeblocks] = useState(true);
  const [timeblocksError, setTimeblocksError] = useState(null);

  // Fetch timeblocks and general settings on component mount
  useEffect(() => {
    const fetchTimeblocks = async () => {
      try {
        const data = await api.get(`${window.baseDomain}api/auth-restaurant/`, { noCache: true });
        setTimeblocks(data.timeblocks || []);
        window.timeblocks = data.timeblocks || []; // Retain globally if needed
        const generalSettings = data['general-settings'] || {};
        window.generalSettings = generalSettings; // Retain globally
      } catch (err) {
        setTimeblocksError(err);
        console.error('Error fetching timeblocks:', err);
      } finally {
        setLoadingTimeblocks(false);
      }
    };

    fetchTimeblocks();
  }, [api]);

  const resetFormDataFields = (fieldsToReset) => {
    setFormData((prevFormData) => {
      const newFormData = { ...prevFormData };
      fieldsToReset.forEach((field) => {
        newFormData[field] = '';
      });
      return newFormData;
    });
  };

  if (loadingTimeblocks) {
    return <div>Loading timeblocks...</div>;
  }

  if (timeblocksError) {
    return <div>Error loading timeblocks: {timeblocksError.message}</div>;
  }

  return (
    <form className="account-manage-form" onSubmit={handleStepOneSubmit} noValidate>
      <ValueSelectorGuests
        value={formData.numberOfGuests}
        onChange={handleChange}
        error={errors.numberOfGuests}
      />

      {formData.numberOfGuests && (
        <DateSelector
          formData={formData}
          handleChange={handleChange}
          resetFormDataFields={resetFormDataFields}
          timeblocks={timeblocks}
        />
      )}

      {formData.date && (
        <TimeSelector
          formData={formData}
          handleChange={handleChange}
          field={{ id: 'time', label: 'Tijd' }}
          selectedDate={formData.date}
        />
      )}

      <button type="submit" className="account-manage__button">
        Verder
      </button>
    </form>
  );
};

export default ReservationStepOne;



Directory Structure for "/Users/thibaultvandesompele/Desktop/Mateza 4.0/Client/Dashboard/dashboard-general/src/Pages/NewReservation/StepOne":

├── Calendar.js
├── DateSelector.js
├── Hooks
│   └── useFetchRestaurantData.js
├── TimeSelector.js
├── Utils
│   ├── dateUtils.js
│   ├── dates
│   │   ├── blockDates.js
│   │   └── schemeDates.js
│   ├── exceptions.js
│   ├── generateDates.js
│   └── generateTimes.js
├── ValueSelector.js
├── css
│   ├── calendar.css
│   ├── timeSelector.css
│   └── valueSelector.css
└── index.js


List of Files:
Calendar.js
DateSelector.js
Hooks/useFetchRestaurantData.js
TimeSelector.js
Utils/dateUtils.js
Utils/dates/blockDates.js
Utils/dates/schemeDates.js
Utils/exceptions.js
Utils/generateDates.js
Utils/generateTimes.js
ValueSelector.js
index.js

**Instruction:**
1. Please encapsulate the main component in index.js inside the `.component-name-component` class.
2. Prefix all CSS classes with the `.component-name-component` class. Sometimes the encapsulation is already done, and we don't need to do it twice. Don't write any comments. Delete all comments and don't write any extra comments. Only print the code with changes. Print the codes in full. Don't skip anything print them full. Mark all changed files with CHANGED before printing the file else mark them with --unchanged and don't print them. Only print every file once.

**Note:** CSS files have been excluded from this prompt.